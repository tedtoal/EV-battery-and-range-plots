################################################################################
# This file contains R definitions and functions for general purpose use.
#
# License: This file may be freely shared.
# Author: Ted Toal
# Date: Apr 2024
#
# Note: This file has a great many functions, but unfortunately, no good
# documentation yet, other than the function header comments.
#
# Change log (most recent entry first):
#
# Date          Name        Description
# -----------   ----------- ----------------------------------------------------
# 13-Apr-2024   Ted         Adjust license for EV-battery-and-range-plots.
# 08-Jan-2020   Ted         Add change log.
################################################################################

cat("Including Include_UtilityFunctions.R\n")

################################################################################
# Partial matching of "$" operator is SO dangerous, and you can't turn it off!!!
################################################################################

options(warnPartialMatchDollar=TRUE)

################################################################################
# Define some universal R constants.
################################################################################

# Rectangle, margin text, regular text, and axis positions.
BOTTOM = 1
LEFT = 2
TOP = 3
RIGHT = 4

# Point types.
pchSquare = 0
pchCircle = 1
pchTriangleOpen = 2
pchPlusSign = 3
pchCross = 4
pchDiamondOpen = 5
pchDelOpen = 6
pchSquareCross = 7
pchStar = 8
pchPlusDiamond = 9
pchPlusCircle = 10
pchJewishStar = 11
pchPlusSquare = 12
pchCrossCircleSquare = 13
pchDelSquare = 14
pchBox = 15
pchMediumDot = 16
pchTriangle = 17
pchDiamond = 18
pchBigDot = 19
pchDot = 20
pchBigDotBg = 21
pchBoxBg = 22
pchDiamondBg = 23
pchTriangleBg = 24
pchDelBg = 25

# Line types.
ltyNone = 0
ltySolid = 1
ltyDashed = 2
ltyDotted = 3
ltyDotDash = 4
ltyLongDash = 5
ltyTwoDash = 6

################################################################################
# Define some biological constants.  When this section grows larger, it should
# be moved to its own include file.
################################################################################

# Define bases.
bases = c("A","T","C","G")

################################################################################
# Often a vector of integers from 1 to N is desired, but N could be 0, in which
# case an EMPTY vector is desired, and 1:N notation fails for that case.  This
# returns the desired vector.
################################################################################
seq1N = function(N) if (N == 0) return(integer(0)) else return(1:N)

################################################################################
# Sample standard error of mean.
################################################################################
sem = function(V) sd(V)/sqrt(length(V))

################################################################################
# Standard deviation, returning 0 if all samples identical.
################################################################################
safe.sd = function(V)
    {
    if (any(is.na(V)))
        return(NA)
    if (all(V == V[1]))
        return(0)
    return(sd(V))
    }

################################################################################
# Capture and return the strings generated by the default print function for object x.
#
# Use this to print R objects that don't print correctly when you use "cat".  E.g. if
# cat(x, "\n") fails, use:   cat(getPrint(x), "\n")
#
# To include space before each line of the output, specify spaces for the prefix argument.
#
# To include a different prefix on the first line, specify it with "firstLinePfx".
#
# The current console width is used unless "width" is specified.
#
# If noLeadingIndexes is TRUE, then the vector indexes of the form "[1]" or [23]" are
# removed from the strings.  If noDoubleQuotes is TRUE, then " characters are removed
# from the strings.
#
# Normally you want to use the default print function for object x, but if you want to
# use a different function, supply it as argument "printFunc".
################################################################################
getPrint = function(x, prefix="", width=NULL, firstLinePfx=prefix,
    noLeadingIndexes=TRUE, noDoubleQuotes=TRUE, printFunc=print)
    {
    tempFile = tempfile("TempFile", fileext=".txt")
    sink(tempFile)
    if (is.null(width))
        width = getOption("width")
    saveWidth = options(width=width-nchar(prefix))
    printFunc(x)
    options(saveWidth)
    sink()
    x = readLines(tempFile)
    if (noLeadingIndexes)
        {
        x = sub("^ *\\[[0-9]+\\] ", "", x)
        x = gsub("\n *\\[[0-9]+\\] ", "", x)
        }
    if (noDoubleQuotes)
        x = gsub('"', "", x)
    x = sub(" $", "", x)
    x = paste(prefix, x, sep="", collapse="\n")
    if (firstLinePfx != prefix)
        x = sub(paste0("^", prefix), firstLinePfx, x)
    return(x)
    }

################################################################################
# Process argument list to look for options.
# This can be used at the start of an R program that is invoked from the command line,
# to examine the arguments for options of the form "-optname value" or "--optname value".
# Note: Rscript spits out a warning about X11 if any option starts with "-g".  The
# warning doesn't prevent the rest of the program from seeing the option, however.
# You can prevent this warning by using --gxxxx instead of -gxxxx.  This function
# accepts either "-" or "--" at the start of an option.
#
# Arguments:
#   args: vector of arguments to examine, could be obtained from commandArgs(TRUE).
#   Options: list of available options and their attributes, may end with NULL
#       which is ignored.  See Details.
#   initDefaults: TRUE to initialize option variables to default values when they have
#       a default specified, FALSE if not.
#   assignValues: TRUE to assign option variables to option value, FALSE if not.
#
# Returns: either a character vector whose value is an error string describing an
# error, or a list with these members:
#   found: a sublist whose member names are names of options that were found, and
#       whose values are the values found for those options.
#   args: args vector modified to remove all options.
# In addition, if 'assignValues' is TRUE, the variables associated with each option
# that was actually specified in 'args' has been set to the value that was specified.
#
# Details:
#
# The 'options' argument is a list describing all available options.  Each list
# element is a sublist of information for one option.  The name of each sublist
# is the option name, that is, the string that must occur preceded by "-" on the
# command line to specify the option.  The members of the sublist are:
#   var: the variable name to be set to the option value if 'assignValues' is TRUE.
#   type: the R type to which the user-specified option is to be converted, e.g.
#       "numeric", "character", "integer", "logical"; or, this may be "flag" to
#       indicate a logical value whose default value is given by 'default' (below)
#       and for which specification of the option (with no argument) sets the value
#       to the complement of the 'default' value; or, this may be "range" to specify
#       an R integer range such as "3:12" or just "5" (equivalent to 5:5) whose
#       variable value is a 2-element vector containing the range endpoints.
# The sublist may also contain these optional members:
#   default: default value for the option.  If not specified, NULL is used.  May be
#       of type 'type' or of type 'character' (in which case it is converted).
#   required: TRUE if the option is required, not optional.  If FALSE and an option
#       is not specified, the 'var' variable remains undefined (test with exists(var)).
#   minval: the minimum allowed value for a "numeric", "integer", or "range" type.
#   maxval: the maximum allowed value for a "numeric", "integer", or "range" type.
#   values: a vector of allowed values for the option.  Not used with "range" type.
#   allowNA: if this is specified and is TRUE, NA is allowed as a value.
#   sep: a string that separates multiple values in a list of values.  If this is
#       not specified, the option is a single value.  If this is specified, the
#       'var' variable is set to a vector of the values when 'assignValues' is TRUE.
#       Not used with "range" type.
#   minNvals: the minimum number of values that must appear in the list when 'sep'
#       is specified, may be 0.  Default is 1.
#   maxNvals: the maximum number of values that must appear in the list when 'sep'
#       is specified, at least minNvals.  Default is no limit.
#
# When "type" is "logical", the user may specify "TRUE", "FALSE", "T", "F", "1",
# "0", "YES", "NO", "Y", or "N" as the value.  When "type" is "flag", no value is
# specified.
#
# For any type, the user may specify "NA" or "N/A" to obtain an NA result, which
# is permissible if "allowNA" is TRUE.
#
# Example options definition and call:
# Options = list(
#     cmax=list(var="cmax", type="numeric", default=30.0, minval=2.0, maxval=100),
#     location=list(var="location", type="character", default="inner", values=c("inner", "outer")),
#     class=list(var="geneClass", type="character", default="TF"),
#     N=list(var="loopCount", type="integer", default=20, required=TRUE),
#     comp=list(var="compress", type="logical", sep=","),
#     bed=list(var="bed", type="flag", default=FALSE)
#     )
# args = commandArgs(TRUE)
# ret = parseOptions(args, Options)
# if (is.character(ret)) stop(ret)
# args = ret$args
# if (length(args) != 1) stop("Usage: Rscript pgm [options] <filename>")
# cat0("loopCount is: ", loopCount, "\n")
# if (!exists("compress"))
#   cat0("compress not specified")
# else
#   cat0("compress is: ", compress, "\n")
################################################################################
parseOptions = function(args, Options, initDefaults=TRUE, assignValues=TRUE)
    {
    if (is.null(Options[[length(Options)]]))
        Options = Options[-length(Options)]

    err = function(S) stop("parseOptions: ", S)

    if (!is.character(args)) err("Expected 'args' to be character")
    if (!is.list(Options)) err("Expected 'Options' to be a list")
    if (is.null(names(Options))) err("Expected 'Options' members to be named")
    x = sapply(Options, function(V) if (!is.list(V)) err("Expected all 'Options' members to be sublists"))
    x = sapply(Options, function(L) if (is.null(L$var)) err("Expected all 'Options' sublists to have a 'var' member"))
    x = sapply(Options, function(L) if (is.null(L$type)) err("Expected all 'Options' sublists to have a 'type' member"))

    # Define a function to convert "value" to a value of type "L$type" (it may already
    # be that).  Test that the value lies within the ranges and other requirements
    # in list L, which is the "Options" argument element for this value.  The 'desc'
    # argument must be a description of what 'value' is, e.g. "Option 'xyz'".  Return
    # either a character string which is an error message, or a list with one element,
    # the value after conversion.
    cvtValue = function(value, L, desc)
        {
        theType = L$type
        # Change type 'flag' to 'logical'
        if (theType == "flag")
            theType = "logical"

        # Type "range" is handled differently than the rest, which are all valid R types.
        if (theType == "range")
            {
            if (class(value) == "integer")
                return(list(c(value, value)))
            if (!grepl("^[0-9]+(:[0-9]+)?$", value))
                return(paste0("-", opt, " value ", value, " is not recognized as of type 'range'"))
            cvtV = as.integer(strsplit(value, ":", fixed=TRUE)[[1]])
            if (!is.null(L$minval) && min(cvtV) < L$minval)
                return(paste0("-", opt, " value must be >= ", L$minval, " but is ", min(cvtV)))
            if (!is.null(L$maxval) && max(cvtV) > L$maxval)
                return(paste0("-", opt, " value must be <= ", L$maxval, " but is ", max(cvtV)))
            return(list(myIfElse(length(cvtV) == 1, cvtV[1], c(cvtV[1], cvtV[2]))))
            }

        # Else it is a valid R type.
        # If 'sep' is specified, split the value into a vector of values if it is a character string.
        if (!is.null(L$sep) && is.character(value))
            {
            if (value != "") # strsplit turns "" into character(0) !!
                value = strsplit(value, L$sep, fixed=TRUE)[[1]]
            minNvals = ifelse(is.null(L$minNvals), 1, L$minNvals)
            maxNvals = max(minNvals, ifelse(is.null(L$maxNvals), length(value), L$maxNvals))
            N = length(value)
            if (N < minNvals)
                return(paste0("-", opt, " must have at least ", minNvals, " values but has ", N))
            if (N > maxNvals)
                return(paste0("-", opt, " must have no more than ", maxNvals, " values but has ", N))
            if (length(value) == 0)
                return(list(vector(theType)))
            }

        # Check each value to see if it is valid, converting it to desired type.
        convertedValue = rep(NA, length(value))
        for (i in 1:length(value))
            {
            V = value[i]
            if (!is.null(L$allowNA) && L$allowNA && (is.na(V) || (is.character(V) && (V %in% c("NA", "N/A")))))
                convertedValue[i] = NA
            else
                {
                sv = options(warn=-1)
                cvtV = as(V, theType)
                if (is.na(cvtV) && theType == "logical")
                    {
                    cvtV = as.numeric(V)
                    if (is.na(cvtV) || (!V %in% c(0, 1)))
                        if (cvtV %in% c("YES", "NO", "Y", "N"))
                            cvtV = cvtV %in% c("YES", "Y")
                    cvtV = as.logical(cvtV)
                    }
                options(sv)
                convertedValue[i] = cvtV
                if (is.na(cvtV))
                    return(paste0("-", opt, " value ", V, " is not recognized as of type '", theType, "'"))
                if (!is.null(L$minval) && cvtV[1] < L$minval)
                    return(paste0("-", opt, " value must be >= ", L$minval, " but is ", V))
                if (!is.null(L$maxval) && cvtV > L$maxval)
                    return(paste0("-", opt, " value must be <= ", L$maxval, " but is ", V))
                if (!is.null(L$values) && !cvtV %in% L$values)
                    return(paste0("-", opt, " has an invalid value: ", V))
                }
            }
        return(list(convertedValue))
        }

    # Assign default values initially, if a default exists.
    if (initDefaults)
        for (opt in names(Options))
            {
            L = Options[[opt]]
            if (!is.null(L$default))
                {
                V = cvtValue(L$default, L, paste0("Option '-", opt, "' default"))
                if (is.character(V))
                    return(V)
                assignGlobal(L$var, V[[1]])
                }
            }

    # n counts up as we skip non-option arguments.
    n = 1

    # Set up return list.
    ret = list(found=list())

    # Parse each argument.
    while (n <= length(args))
        {
        # If argument doesn't start with '-' it is not an option.
        if (!grepl("^-", args[n]))
            n = n + 1
        else
            {
            # Get the option name and remove it from args.  Remove the "-".
            opt = sub("^-", "", args[n])
            args = args[-n]

            # If it starts with "--", remove the second "-" also.
            if (grepl("^-", opt))
                opt = sub("^-", "", opt)

            # Look up the option name in 'Options' list.
            idx = which(opt == names(Options))
            if (length(idx) != 1)
                return(paste0("Unknown option: ", opt))
            L = Options[[idx]]

            # The option must have a value as the next argument, unless it is
            # of type "flag", in which case set 'value' to !L$default (or TRUE
            # if L$default is NULL).
            if (L$type == "flag")
                value = ifelse(is.null(L$default), TRUE, !L$default)
            else
                {
                if (length(args) < n)
                    return(paste0("Missing value for option '", opt, "'"))
                value = args[n]
                args = args[-n]
                }

            # Convert the value to the target type and save it in "found".
            V = cvtValue(value, L, paste0("Option '-", opt, "'"))
            if (is.character(V))
                return(V)
            ret$found[[opt]] = V[[1]]

            # Assign the value to the variable.
            if (assignValues)
                assignGlobal(L$var, V[[1]])
            }
        }

    # Save the modified args vector.
    ret$args = args

    # Check to see if all required options were specified.
    notFound = setdiff(names(Options), names(ret$found))
    required = sapply(notFound, function(opt) Options[[opt]]$required)
    notSpecified = sapply(required, function(req) !is.null(req) && req)
    if (any(notSpecified))
        return(paste("Required option(s) not specified: ", paste(names(notSpecified)[notSpecified], collapse=","), sep=""))

    # Finished.
    return(ret)
    }

################################################################################
# Replace special substrings within a string with values given by a list of lists.
#
# Arguments:
#   SS: vector of one or more substrings to undergo replacement.
#   LL: list of sublists, with sublists having names and elements in sublists
#       also named unless the 'sep' argument is "".
#   left: character(s) marking start of a replacement field, in regular expression
#       form.
#   right: character(s) marking end of a replacement field, in regular expression
#       form.  May be empty string.
#   sep: character occurring in SS between 'left' and 'right' that separates an
#       LL sublist name from an LL sublist element name.  If "", this means that
#       the LL sublist elements do not have to have names.
#   name.subnameRE: R regular expression string matching anything that might
#       occur in SS between 'left' and 'right', including sep.
#   replaceSep: if the replacement value is a vector of more than one value, the
#       values are collapsed into a single string for replacement, with this
#       separating the values.
#
# Returns: SS with replacements made.
#
# Details:
# The SS strings are scanned for any that match name.subnameRE (with the 'left'
# and 'right' character strings located left and right of the matching expression),
# and the matching substrings are extracted and the LL sublist name and sublist
# element name are extracted, then those names are used to look up the replacement
# value in LL.  The SS strings are modified with the replacement value, and the
# process is repeated until there are no more matches.
#
# Example 1: simple replacement
#   SS = "Hello {A} and {B}"
#   LL = list(A="Ted", B="John")
#   replaceSubstrings(SS, LL, "\\{", "}", "")
#   (result is "Hello Ted and John")
#
# Example 2: complex replacement
#   SS = "A min is %%A$min and B min is %%B$min and B vals are %%B$vals"
#   LL = list(A=list(min=40), B=list(min=2, vals=5:10))
#   replaceSubstrings(SS, LL)
#   (result is "A min is 40 and B min is 2 and B vals are 5,6,7,8,9,10")
################################################################################
replaceSubstrings = function(SS, LL, left="%%", right="", sep="$",
    name.subnameRE="[A-Za-z0-9_.$]+", replaceSep=",")
    {
    RE = paste0("^(.*)", left, "(", name.subnameRE, ")", right, "(.*)$")
    hasSubstring = grepl(RE, SS)
    while (any(hasSubstring))
        {
        ss.left = sub(RE, "\\1", SS[hasSubstring])
        ss.ctr = sub(RE, "\\2", SS[hasSubstring])
        ss.right = sub(RE, "\\3", SS[hasSubstring])
        if (sep == "")
            names.1 = ss.ctr
        else
            {
            ss.names = strsplit(ss.ctr, sep, fixed=TRUE)
            badLens = sapply(ss.names, function(V) length(V) != 2)
            if (any(badLens))
                stop("replaceSubstrings: expected two strings separated by ", sep,
                    " but not found in ", paste(ss.ctr[badLens], collapse=" : "))
            names.1 = sapply(ss.names, '[', 1)
            names.2 = sapply(ss.names, '[', 2)
            }
        sublists = LL[names.1]
        notFound = sapply(sublists, is.null)
        if (any(notFound))
            stop("replaceSubstrings: unknown sublist name(s): ", paste(names.1[notFound], collapse=" : "))
        subelementValues = sapply(1:length(names.1), function(i)
            {
            V = sublists[[i]]
            if (sep != "")
                {
                V = V[[names.2[i]]]
                if (is.null(V))
                    stop("replaceSubstrings: unknown sublist element name: ", paste(names.2[i], collapse=" : "))
                }
            if (length(V) > 1)
                V = paste(V, collapse=replaceSep)
            return(V)
            })
        SS[hasSubstring] = paste0(ss.left, subelementValues, ss.right)
        hasSubstring = grepl(RE, SS)
        }
    return(SS)
    }

################################################################################
# Compare 2 numeric values to see if they differ by no more than tol.  x1 and x2
# may be vectors.  Return logical vector, TRUE if they differ by more than tol.
################################################################################
differMoreThanTol = function(x1, x2, tol=0.001)
    {
    return(abs(x1 - x2) > tol)
    }

################################################################################
# Test vector to see if any elements are NA strings or the NA value after
# trimming whitespace from start and end of each string.
#
# Arguments:
#   x: character, integer, or numeric vector whose elements are to be tested for
#       the NA value or for NA strings.
#   NAstrings: vector of strings permitted as NA strings.  If NULL, default is to use
#       "NA", "N/A", and "" as the strings, and NA itself so that an NA element of x
#       also counts as NA.
#   ignore.case: If TRUE, case of x strings is ignored.
#
# Returns: logical vector equal in length to x, TRUE means element is NA or an
# NA string and FALSE means it isn't.
################################################################################
isNAstring = function(x, NAstrings=NULL, ignore.case=TRUE)
    {
    if (!is.character(x) && !is.numeric(x))
        stop("isNAstring requires character or numeric argument")
    V = is.na(x)
    if (is.character(x))
        {
        x = x[!V]
        if (is.null(NAstrings))
            NAstrings = c("NA", "N/A", "", NA)
        x = trimws(x)
        if (ignore.case)
            x = toupper(x)
        V[!V] = (x %in% NAstrings)
        }
    return(V)
    }

################################################################################
# Like is.integer except NA and NA strings are recognized and treated as integers.
#
# Arguments:
#   x: character, integer, or numeric vector whose elements are to be tested
#       for integer.
#   NAstrings: See isNAstring().
#   ignore.case: If TRUE, case of x strings is ignored.
#
# Returns: logical vector equal in length to x, TRUE means element is an integer
# value or string or NA or an NA string and FALSE means it isn't.
################################################################################
isInteger = function(x, NAstrings=NULL, ignore.case=TRUE)
    {
    if (is.integer(x))
        return(rep(TRUE, length(x)))
    if (is.numeric(x) & all(x == ceiling(x)))
        return(rep(TRUE, length(x)))
    if (all(is.na(x)))
        return(rep(TRUE, length(x)))
    if (!is.character(x))
        stop("isInteger requires character or integer argument")
    V = isNAstring(x, NAstrings, ignore.case)
    V[!V] = grepl("^(\\+|\\-)?[0-9]+$", trimws(x[!V]))
    return(V)
    }

################################################################################
# Like as.integer except NA and NA strings are recognized and treated as integers.
#
# Arguments:
#   x: character, integer, or numeric vector whose elements are to be converted
#       to integer.
#   NAstrings: See isNAstring().
#   ignore.case: If TRUE, case of x strings is ignored.
#
# Returns: integer vector equal in length to x, containing integer values when
# there were integers or integer strings in x, or containing NA when there were
# NA values or NA strings in x.  Other values in x insert NA with a warning message.
################################################################################
asInteger = function(x, NAstrings=NULL, ignore.case=TRUE)
    {
    if (is.integer(x))
        return(x)
    if (is.numeric(x) && all(x == ceiling(x)))
        return(as.integer(x))
    if (all(is.na(x)))
        return(as.integer(x))
    if (!is.character(x))
        stop("asInteger requires character or integer argument")
    NAstr = isNAstring(x, NAstrings, ignore.case)
    V = rep(NA, length(x))
    V[!NAstr] = as.integer(x[!NAstr])
    return(V)
    }

################################################################################
# Like is.numeric except NA and NA strings are recognized and treated as numeric.
#
# Arguments:
#   x: character, integer, or numeric vector whose elements are to be tested for
#       numeric.
#   NAstrings: See isNAstring().
#   ignore.case: If TRUE, case of x strings is ignored.
#
# Returns: logical vector equal in length to x, TRUE means element is numeric
# value or string or NA or an NA string and FALSE means it isn't.
################################################################################
isNumeric = function(x, NAstrings=NULL, ignore.case=TRUE)
    {
    if (is.numeric(x))
        return(rep(TRUE, length(x)))
    if (all(is.na(x)))
        return(rep(TRUE, length(x)))
    if (!is.character(x))
        stop("isNumeric requires character or numeric argument")
    V = isNAstring(x, NAstrings, ignore.case)
    x[!V] = trimws(x[!V])
    V[!V] = (x != "") & grepl("^(\\+|\\-)?([0-9]*)?\\.?([0-9]*)([eE](\\+|\\-)?[0-9]+)?$", x)
    return(V)
    }

################################################################################
# Like as.numeric except NA and NA strings are recognized and treated as numeric.
#
# Arguments:
#   x: character, integer, or numeric vector whose elements are to be converted
#       to numeric.
#   NAstrings: See isNAstring().
#   ignore.case: If TRUE, case of x strings is ignored.
#
# Returns: numeric vector equal in length to x, containing numeric values when
# there were numeric values or numeric strings in x, or containing NA when there
# were NA values or NA strings in x.  Other values in x insert NA with a warning
# message.
################################################################################
asNumeric = function(x, NAstrings=NULL, ignore.case=TRUE)
    {
    if (is.integer(x))
        return(as.numeric(x))
    if (is.numeric(x))
        return(x)
    if (all(is.na(x)))
        return(as.numeric(x))
    if (!is.character(x))
        stop("asNumeric requires character or numeric argument")
    NAstr = isNAstring(x, NAstrings, ignore.case)
    V = rep(NA, length(x))
    V[!NAstr] = as.numeric(x[!NAstr])
    return(V)
    }

################################################################################
# Like is.vector except returns FALSE if is.list also returns TRUE.
#
# Arguments:
#   x: R object to be tested to see if it is a vector but not a list.
#
# Returns: TRUE if x is a vector but not a list, else FALSE.
################################################################################
isNonListVector = function(x)
    {
    return(!is.list(x) && is.vector(x))
    }

################################################################################
# Test character vector to see if any elements are logical strings after
# trimming whitespace from start and end of each string, returning TRUE or FALSE
# if they are, and returning NA if not.
#
# Arguments:
#   x: character, logical, integer, or numeric vector whose elements are to be
#       tested for logical strings.
#   TRUEstrings: vector of strings permitted as TRUE strings.  If NULL, default is to
#       use "true", "t", "1", "yes", and "y".
#   FALSEstrings: vector of strings permitted as FALSE strings.  If NULL, default is to
#       use "false", "f", "0", "no", and "n".
#   ignore.case: If TRUE, case of x strings is ignored.
#
# Returns: logical vector equal in length to x, TRUE means element is a logical
# TRUE value or string, FALSE means it is a logical FALSE value or string, and
# NA means it is something else or the value itself is NA.
#
# Note: this is a worker function for isLogical() and toLogical().
################################################################################
toLogicalString = function(x, TRUEstrings=NULL, FALSEstrings=NULL, ignore.case=TRUE)
    {
    if (is.logical(x))
        return(x)
    if (is.numeric(x))
        return(as.logical(x))
    if (!is.character(x))
        stop("toLogicalString requires character, logical, or numeric argument")
    if (is.null(TRUEstrings))
        TRUEstrings = c("true", "t", "1", "yes", "y")
    if (is.null(FALSEstrings))
        FALSEstrings = c("false", "f", "0", "no", "n")
    x = trimws(x)
    if (ignore.case)
        x = tolower(x)
    V = (x %in% TRUEstrings)
    V[!V][!(x[!V] %in% FALSEstrings)] = NA
    return(V)
    }

################################################################################
# Like is.logical except special TRUE, FALSE, and NA and NA strings are
# recognized and treated as logicals.
#
# Arguments:
#   x: character, logical, integer, or numeric vector whose elements are to be
#       tested for logical.
#   TRUEstrings: See toLogicalString().
#   FALSEstrings: See toLogicalString().
#   NAstrings: See isNAstring().
#   ignore.case: If TRUE, case of x strings is ignored.
#
# Returns: logical vector equal in length to x, TRUE means element is a logical
# or numeric value or logical string or NA value or string and FALSE means it
# isn't.
################################################################################
isLogical = function(x, TRUEstrings=NULL, FALSEstrings=NULL, NAstrings=NULL, ignore.case=TRUE)
    {
    if (is.logical(x) || is.numeric(x))
        return(rep(TRUE, length(x)))
    if (!is.character(x))
        stop("isLogical requires character, logical, or numeric argument")
    V = isNAstring(x, NAstrings, ignore.case)
    V[!V] = !is.na(toLogicalString(x[!V], TRUEstrings, FALSEstrings, ignore.case))
    return(V)
    }

################################################################################
# Like as.logical except special TRUE, FALSE, and NA strings are recognized and
# treated as logicals.
#
# Arguments:
#   x: character, logical, integer, or numeric vector whose elements are to be
#       converted to logical.
#   TRUEstrings: See toLogicalString().
#   FALSEstrings: See toLogicalString().
#   NAstrings: See isNAstring().
#   ignore.case: If TRUE, case of x strings is ignored.
#
# Returns: logical vector equal in length to x, containing logical values when
# there were logical or numeric values or logical strings in x, or containing
# NA when there were NA values or strings in x.  Other values in x insert NA
# with a warning message.
################################################################################
asLogical = function(x, TRUEstrings=NULL, FALSEstrings=NULL, NAstrings=NULL, ignore.case=TRUE)
    {
    if (is.logical(x))
        return(x)
    if (is.numeric(x))
        return(as.logical(x))
    if (!is.character(x))
        stop("asLogical requires character, logical, or numeric argument")
    NAstr = isNAstring(x, NAstrings, ignore.case)
    V = rep(NA, length(x))
    logStr = toLogicalString(x[!NAstr], TRUEstrings, FALSEstrings, ignore.case)
    V[!NAstr] = logStr
    V[!NAstr][is.na(logStr)] = as.logical(x[!NAstr][is.na(logStr)])
    return(V)
    }

################################################################################
# Like as() except asLogical() is used for type 'logical' and asInteger() for
# type 'integer'.
#
# Arguments:
#   x: character vector whose elements are to be converted.
#   class: name of R class to which to convert.
#
# Returns: vector equal in length to x, containing converted values.
################################################################################
myAs = function(x, class)
    {
    if (class == "logical")
        return(asLogical(x))
    if (class == "integer")
        return(asInteger(x))
    return(as(x, class))
    }

################################################################################
# Define ifelse() that works better.  The usual R ifelse() forces the yes and no values
# to be of the same "shape" as the test argument.  We make some reasonable assumptions
# here, although if the lengths of the args vary one to another, who knows what is right?
# Also, we provide an optional fourth argument which is assigned as the result when the
# test value is NA.
################################################################################
myIfElse = function(test, yes, no, na=NA)
    {
    if (class(c(test)) != "logical")
        stop("myIfElse request test to be type logical, or an array of type logical, but it is: ",
            class(c(test)), ", e.g. first element is: ", c(test)[1])

    # First handle case where test is an array (matrix or higher dimension).
    if (is.array(test))
        {
        if (any(is.null(yes)) || any(is.null(no)))
            stop("myIfElse requires non-NULL for arrays")
        if (!is.array(yes))
            yes = array(rep(yes, length.out=length(test)), dim=dim(test))
        else if (length(dim(test)) != length(dim(yes)) || !all(dim(test) == dim(yes)))
            stop("myIfElse requires test and yes array args to be of same dimension")
        if (!is.array(no))
            no = array(rep(no, length.out=length(test)), dim=dim(test))
        else if (length(dim(test)) != length(dim(no)) || !all(dim(test) == dim(no)))
            stop("myIfElse requires test and no array args to be of same dimension")
        if (!is.array(na))
            na = array(rep(na, length.out=length(test)), dim=dim(test))
        else if (length(dim(test)) != length(dim(na)) || !all(dim(test) == dim(na)))
            stop("myIfElse requires test and na array args to be of same dimension")
        result = yes
        result[!is.na(test) & !test] = no[!is.na(test) & !test]
        result[is.na(test)] = na[is.na(test)]
        return(result)
        }
    # Next handle case where test is a simple scalar.
    if (length(test) == 1)
        {
        if (is.na(test))
            return(na)
        if (test)
            return(yes);
        return(no);
        }
    # Assume test is a vector.
    if (any(is.null(yes)) || any(is.null(no)))
        stop("myIfElse requires non-NULL for vectors")
    if (length(test) != length(yes))
        yes = rep(yes, length.out=length(test))
    if (length(test) != length(no))
        no = rep(no, length.out=length(test))
    if (length(test) != length(na))
        na = rep(na, length.out=length(test))
    result = yes
    result[!is.na(test) & !test] = no[!is.na(test) & !test]
    result[is.na(test)] = na[is.na(test)]
    names(result) = NULL
    return(result)
    }

################################################################################
# Apply a function to two vectors derived from two given vectors by removing
# n elements from the start of one of them and from the end of the other.
#
# This could, for example, compute the distance between segments if a data
# frame contains the start and end positions of a set of segments.  That
# distance would be obtained by subtracting the start position of one segment
# from the end position of the following segment, and this can be accomplished
# by removing the first end position and last start position (i.e. n=1).  The
# result would be one element shorter than the number of data frame rows.
#
# Arguments:
#   v1, v2: two equal-sized vectors, usually different but sometimes the same.
#   f: a function which takes as arguments two equal-sized vectors m1 and m2,
#       which will be derived from v1 and v2 by removal of n elements from the
#       start of one and from the end of the other.  The return value is a
#       single vector, normally the same size as v1m and v2m, although this
#       is not a requirement.
#   n: number of elements to remove from start/end of v1 and v2 to obtain m1
#       and m2, which are passed to f().  If n is positive, n elements are
#       removed from the START of v1 and from the END of v2.  If n is negative,
#       n elements are removed from the END of v1 and from the START of v2.
#       The default value of 1 is the typical value used.
#   first, last: at least one of these must be NA.  If one is not NA, its value
#       is replicated abs(n) times and concatenated to the start (for 'first')
#       or end (for 'last') of the vector returned by f().
#
# Returns: the vector returned by f(), possibly modified by addition of elements
# via arguments 'first' and 'last'.
#
# Note: with the default arguments, vvm(v) is the same as diff(v).
#
# Example: suppose a data frame df contains three columns, chr, start, and end,
# that give positions of segments on chromosomes, and you wish to obtain the
# subset of df rows whose segment overlaps that of the following row, same
# chromosome:
#               sameChr = vvm(df$chr, f=function(m1,m2) m1 == m2, last=FALSE)
#               overlap = vvm(df$start, df$end, f=function(m1,m2) m1 >= m2, last=FALSE)
#               df = df[sameChr & overlap,]
################################################################################
vvm = function(v1, v2=v1, f=function(m1, m2) {m1-m2}, n=1, first=NA, last=NA)
    {
    N = length(v1)
    absn = abs(n)
    if (N != length(v2)) stop("v1 and v2 must have same length")
    if (absn >= N) stop("n must be < length(v1)")
    if (n > 0)
        {
        m1 = v1[-(1:n)]
        m2 = v2[-((N-n+1):N)]
        }
    else if (n < 0)
        {
        m1 = v1[-((N-absn+1):N)]
        m2 = v2[-(1:absn)]
        }
    else
        {
        m1 = v1
        m2 = v2
        }
    v = f(m1, m2)
    if (!is.na(first))
        v = c(rep(first, absn), v)
    if (!is.na(last))
        v = c(v, rep(last, absn), v)
    return(v)
    }

################################################################################
# Like which.min() and which.max() except the NAME of the first minimum/maximum index is returned.
################################################################################
which.name.min = function(v)
    {
    return(names(v)[which.min(v)])
    }

which.name.max = function(v)
    {
    return(names(v)[which.max(v)])
    }

################################################################################
# Return the greatest common divisor of the integers in vector V.
################################################################################
GCD = function(V)
    {
    if (!is.numeric(V)) stop("GCD: non-numeric argument")
    V = V[!is.na(V)]
    if (length(V) < 2) stop("GCD: need at least two non-NA values")
    IV = as.integer(V)
    if (any(IV != V)) stop("GCD: some arguments are not integers")
    if (any(IV < 1)) stop("GCD: some arguments are < 1")

    # Handle length(IV) > 2
    N = length(IV)
    while (N > 2)
        {
        IV = c(IV[1:(N-2)], GCD.fast(IV[(N-1):N]))
        N = N - 1
        }

    return(GCD.fast(IV))
    }

# Compute gcd of IV[1] and IV[2], no error checking.
GCD.fast = function(IV)
    {
    while (IV[1] > 0)
        IV = c(IV[2] %% IV[1], IV[1]);
    return(IV[2]);
    }

################################################################################
# Return the least common multiple of the integers in vector V.
################################################################################
LCM = function(V)
    {
    if (!is.numeric(V)) stop("LCM: non-numeric argument")
    V = V[!is.na(V)]
    if (length(V) < 2) stop("LCM: need at least two non-NA values")
    IV = as.integer(V)
    if (any(IV != V)) stop("LCM: some arguments are not integers")
    if (any(IV < 1)) stop("LCM: some arguments are < 1")

    # Handle length(IV) > 2
    if (length(IV) > 2)
        IV = c(IV[1], LCM.fast(IV[-1]))

    # Compute lcm of IV[1] and IV[2]
    return(LCM.fast(IV))
    }

# Compute lcm of IV[1] and IV[2], no error checking.
LCM.fast = function(IV)
    {
    return(IV[1]*IV[2]/GCD(IV));
    }

################################################################################
# Add a vector n of names to a vector v and return the result.
################################################################################
addNamesToVector = function(v, n)
    {
    names(v) = n
    return(v)
    }

################################################################################
# Create a vector whose names are given by vector n and whose values are equal
# to v, which is recycled to length(n).  Oops, this is much the same as
# setNames, but with args swapped.
################################################################################
makeNamedVector = function(n, v=0)
    {
    V = rep(v, length.out=length(n))
    names(V) = n
    return(V)
    }

################################################################################
# Like setNames() (or makeNamedVector()) except this allows row and column names
# to be set on data frames and matrices, and additional names to be set on
# multi-dimensional arrays.
################################################################################
setNamesMulti = function(x, rowNames=rownames(x), colNames=colnames(x), ...)
    {
    L = list(rowNames, colNames, ...)
    N = length(dim(x))
    while (length(L) < N)
        L = c(L, list(NULL))
    if (length(L) > N)
        stop("Too many dimnames vectors specified")
    dimnames(x) = L
    return(x)
    }

################################################################################
# Make a vector be "complete" in the sense that it has all of a set of specified indexes.
# If necessary, expand the size of a vector, retaining the existing values but putting
# them in a specified order, and adding new elements in that order and preset to a
# specified value.
#
# Arguments:
#   V: vector to be completed, may be NA if you simply want to make a vector with
#       names n and values v.
#   n: vector of names for the completed vector.  This should include all the names of
#       V, and any element of V whose name is not in this vector is omitted from the
#       returned vector.  If V is a table() return value and the names of V are
#       integers, use as.character(numeric indexes) for this argument.
#   v: initial value to use for new elements of V.
#
# Returns: a vector of length length(n), whose names are n, and whose values are v
# except that those elements whose names were also names in V have the value from V.
################################################################################
completeVector = function(V, n, v=0)
    {
    V = V[n]
    V[is.na(V)] = v
    names(V) = n
    return(V)
    }

################################################################################
# Convert a table (from the table function) to a vector.  Optionally, return
# only specified indexes from the table.  Optionally, change NA entries to
# useForNA.
################################################################################
tableToVector = function(tbl, idxs=NULL, useForNA=NA)
    {
    V = setNames(as.vector(tbl), names(tbl))
    if (!is.null(idxs))
        {
        V = V[idxs]
        if (is.character(idxs))
            names(V) = idxs
        }
    if (!is.na(useForNA))
        V[is.na(V)] = useForNA
    return(V)
    }

################################################################################
# Return the names of the elements of each list L element, flattened into a
# vector, e.g. if L=list(A=c(x=1, y=2), B=c(z=3)), c("x", "y", "z") is returned.
# If the inner element is a matrix or data frame, return the COLUMN names unless
# useRowNames is TRUE, in which case the row names.  If L is a vector or matrix
# rather than a list, treat it as a list with that one element in it.
################################################################################
inner.names = function(L, useRowNames=FALSE)
    {
    if (!is.list(L))
        L = list(L)
    return(unlist(sapply(L, function(E)
        if (is.matrix(E) || is.data.frame(E))
            {
            if (useRowNames)
                return(rownames(E))
            else
                return(colnames(E))
            }
        else
            return(names(E))),
        recursive=FALSE, use.names=FALSE))
    }

################################################################################
# Like unlist(L, recursive=FALSE) except that the names of the resulting
# elements are the names of the inner elements (whereas unlist() uses names of
# the form "XXX.YYY" where XXX=outer element names, YYY=inner element names).
# See inner.names for useRowNames description.
################################################################################
unlist.useInnerNames = function(L, useRowNames=FALSE)
    {
    V = unlist(L, recursive=FALSE, use.names=FALSE)
    names(V) = inner.names(L, useRowNames)
    return(V)
    }

################################################################################
# Make an empty data frame having the specified column names and column types.
#
# Arguments:
#   colNamesTypes: list whose element names are column names and whose element
#       values are the same type as the desired column type.
#
# Returns: empty data frame, with stringsAsFactors=FALSE.
################################################################################
makeEmptyDataframe = function(colNamesTypes)
    {
    return(as.data.frame(colNamesTypes, stringsAsFactors=FALSE)[c(),])
    }

################################################################################
# Like nrow(dataFrame) except that if dataFrame is NULL, 0 is returned, not NULL.
#
# Arguments:
#   df: a data frame or NULL.
#
# Returns: number of rows in the data frame, 0 if df is NULL.
################################################################################
nrowsDataframe = function(df)
    {
    if (is.null(df))
        return(0)
    return(nrow(df))
    }

################################################################################
# Extract a column of a data frame as a vector with names equal to the data frame row names.
################################################################################
getDataframeColumnAsNamedVector = function(df, col=1)
    {
    v = df[,col]
    names(v) = rownames(df)
    return(v)
    }
df.col.as.vector = function(df, col=1) getDataframeColumnAsNamedVector(df, col)

################################################################################
# Extract a row of a data frame as a vector with names equal to the data frame column names.
################################################################################
getDataframeRowAsNamedVector = function(df, row=1)
    {
    v = as.vector(as.matrix(df[row,]))
    names(v) = colnames(df)
    return(v)
    }
df.row.as.vector = function(df, row=1) getDataframeRowAsNamedVector(df, row)

################################################################################
# When y = sapply(x, ...) has names on x, the result y has the same names.
# Typically this is not what you want.  Instead, you want the names of y to be
# x, not names(x).  That is what this function does.
################################################################################
sapply.ignoreNames = function(x, ...)
    {
    names(x) = NULL
    return(do.call(sapply, list(x, ...)))
    }

################################################################################
# Handle smart sapply(..., simplify=TRUE).
#
# Typically simplify=TRUE is used with sapply() when each iteration returns a
# vector of the same length.  If length is 1, sapply returns a vector, and if
# length > 1, sapply returns a matrix.
#
# If the returned vector length can vary between 1 and larger values, the user
# wants a MATRIX to be returned, even if the length is 1.  In that case, he wants
# a 1-row matrix to be returned.  However, sapply() returns a vector.
#
# This function is meant for use when simplify=TRUE is specified and the return
# value should be a matrix.  It calls sapply(...), then checks the returned value.
# If it is a vector, it uses t() on it to change it to a 1-row matrix.
#
# Arguments:
#   ...: Arguments to pass to sapply().
#
# Returns: sapply() return value, but if it returns a vector, a 1-row matrix of
# that vector is returned.
################################################################################
sapply.matrix = function(...)
    {
    x = do.call(sapply, list(...))
    if (!is.vector(x))
        return(x)
    return(t(x))
    }

################################################################################
# Handle smart transposition of a matrix returned by apply(mtx, 1, ...).
#
# When apply() is applied by row to a matrix, and the return values are vectors of
# the same length as each row vector, the returned value is a matrix whose size is
# transposed from the input matrix:
#       mtx.out = apply(mtx.in, 1, identity) # dim(mtx.out) is swapped from dim(mtx.in)
# The transpose is most likely not desired, and the solution is to transpose the result:
#       mtx.out = t(apply(mtx.in, 1, identity))
# This works unless mtx.in has 1 column.  Then, apply() returns a vector instead of
# a matrix, and applying t() to it returns a matrix that is the transpose of the
# 1-column matrix we want:
#       mtx.out = t(apply(mtx.in, 1, identity)) # dim(mtx.out) is swapped from dim(mtx.in)
# The solution in this case is to apply t() TWICE.
#
# Arguments:
#   MV: matrix to be transposed, or a vector to be turned into a 1-column matrix.
#
# Returns: a matrix that is the transpose of MV if MV is a matrix, or that is a matrix
# with one column equal to MV if MV is a vector.
################################################################################
smartTranspose = function(MV)
    {
    if (is.matrix(MV))
        return(t(MV))
    return(t(t(MV)))
    }

################################################################################
# Handle apply(x, 1, ...), where the function is applied over the ROWS of matrix
# x, and where the apply function argument return values are vectors of the same
# length as the matrix rows and we want the apply() return value to be a matrix
# that is the same size as x.  See comments in smartTranspose().
#
# Arguments:
#   x: the "x" argument of apply().
#   ...: Arguments following the "MGN" argument of apply, to pass to apply().
#
# Returns: apply() return value modified by smartTranspose() to be a matrix the
# same size as x (if the ... function returns vectors equal in length to nrow(x))
################################################################################
apply.rows = function(x, ...)
    {
    x = do.call(apply, c(list(x, 1), ...))
    return(smartTranspose(x))
    }

################################################################################
# Normalize the rows of a matrix so that each sums to the specified value(s).
#
# Arguments:
#   M: matrix to be normalized.
#   V: value to which each row is to sum after normalization.  May be a vector,
#       recycled to nrow(M).
#
# Returns: normalized matrix whose rows sum to V (or 0), obtained by dividing each row
#   by sum(row)/V[rowIdx].
################################################################################
rowNormalize = function(M, V=1)
    {
    if (any(V == 0)) stop("rowNormalize: argument V has a 0 in it")
    return(M/(rowSums(M)/rep(V, length.out=nrow(M))))
    }

################################################################################
# Normalize the columns of a matrix so that each sums to the specified value(s).
#
# Arguments:
#   M: matrix to be normalized.
#   V: value to which each column is to sum after normalization.  May be a vector,
#       recycled to ncol(M).
#
# Returns: normalized matrix whose columns sum to V (or 0), obtained by dividing each
#   column by sum(column)/V[colIdx].
################################################################################
colNormalize = function(M, V=1)
    {
    if (any(V == 0)) stop("colNormalize: argument V has a 0 in it")
    V = colSums(M)/rep(V, length.out=ncol(M))
    return(smartTranspose(apply(M, 1, function(Vcol) Vcol/V)))
    }

###########################################################################
# Perform rbind on two data frames after first checking to make sure they
# have the same column names.  NULL values are simply passed to rbind.
###########################################################################
safe.rbind = function(df1, df2)
    {
    if (is.null(df1) || is.null(df2) || nrow(df1) == 0 || nrow(df2) == 0)
        return(rbind(df1, df2))
    if (ncol(df1) != ncol(df2) || any(colnames(df1) != colnames(df2)))
        {
        cat0("columns differ:\n")
        N1 = min(ncol(df1), ncol(df2))
        N2 = max(ncol(df1), ncol(df2))
        for (i in 1:N1)
            cat(sprintf("  %10s vs %10s\n", colnames(df1)[i], colnames(df2)[i]))
        if (N1 < N2)
            for (i in (N1+1):N2)
                {
                if (ncol(df1) < i)
                    cat(sprintf("  %10s vs %10s\n", "(none)", colnames(df2)[i]))
                else
                    cat(sprintf("  %10s vs %10s\n", colnames(df1)[i], "(none)"))
                }
        stop("column mismatch")
        }
    return(rbind(df1, df2))
    }

###########################################################################
# Perform cbind on two or more vectors or data frames.  If any are NULL or
# of length 0, they are skipped. (cbind gives an error in that case).  If
# you want one or more arguments to cause a return of NULL if the argument
# is NULL or of length 0, name the argument with a name that starts with
# "NULLif0".
###########################################################################
smart.cbind = function(...)
    {
    args = list(...)

    # Collect all non-empty args in L.  The names of empty or NULL arguments
    # are checked to see if they start with "NULLif0", and if so, NULL is
    # returned.
    L = list()
    while (length(args) > 0)
        {
        arg = args[[1]]
        argName = names(args)[1]
        args = args[-1]
        if (is.null(arg) ||
            (is.data.frame(arg) && nrow(arg) == 0) ||
            (!is.data.frame(arg) && length(arg) == 0))
            {
            if (length(argName) == 1 && grepl("^NULLif0", argName))
                return(NULL)
            next
            }
        L = c(L, list(arg))
        }
    if (length(L) == 0)
        return(NULL)

    # Do cbind on L.
    return(do.call(cbind, L))
    }

################################################################################
# An alternative to rbind() that is far, far faster.
#
# Arguments:
#   df1: First data frame to be bound together row-wise, or a list previously
#       returned by this function, or NULL to indicate an empty data frame.
#   df2: Second data frame to be bound together row-wise, or a list previously
#       returned by this function, or NULL to indicate an empty data frame.
#
# Returns: a list containing the data in df1 and df2.  To convert this list to
#   a data frame, use rbind.fast.finish().  The returned list has an attribute
#   named "nrow", containing the number of rows in total.  Do not add to or
#   subtract from the returned lists yourself.
#
# Note: When df1 or df2 is a data frame, if the first row name is not composed
# entirely of digits, the row names are saved in sublist element ".rownames",
# and are also accumulated when each new data frame is added.  Both data frames
# must have row names if they are present at all, and the row names must all be
# unique.  No checking is done here for that.
#
# Example of speed:
#
# N = 10000
# Na = 1:N
# Nb = (N+1):(2*N)
#
# f1 = function()
#   {
#   df1 = NULL
#   for (i in 1:100)
#       df1 = rbind(df1, data.frame(a=Na, b=Nb, row.names=paste0("A", i, "_", Na)))
#   return(df1)
#   }
#
# f2 = function()
#   {
#   df2 = NULL
#   for (i in 1:100)
#       df2 = rbind.fast(df2, data.frame(a=Na, b=Nb, row.names=paste0("A", i, "_", Na)))
#   df2 = rbind.fast.finish(df2)
#   return(df2)
#   }
#
# system.time(df1 <- f1())
#    user  system elapsed
#   7.901   3.395  11.460
# system.time(df2 <- f2())
#    user  system elapsed
#   0.056   0.004   0.070
# identical(df1, df2)
# [1] TRUE
################################################################################
rbind.fast = function(df1, df2)
    {
    if (!(is.null(df1) || is.data.frame(df1) || (is.list(df1) && is.list(df1[[1]]))) ||
        !(is.null(df2) || is.data.frame(df2) || (is.list(df2) && is.list(df2[[1]]))))
        stop("rbind.fast only works with NULL or data frame or list of lists arguments")

    # Convert df1 from data frame to list if not already done.  Each list element
    # is itself a list.
    if (is.data.frame(df1))
        {
        nr = nrow(df1)
        R = rownames(df1)
        df1 = as.list(df1)
        for (n in names(df1))
            df1[[n]] = list(df1[[n]])
        if (length(R) > 0 && !grepl("^[0-9]+$", R[1]))
            df1$.rownames = R
        attr(df1, "nrow") = nr
        }

    # Convert df2 from data frame to list if not already done.  Each list element
    # is itself a list.
    if (is.data.frame(df2))
        {
        nr = nrow(df2)
        R = rownames(df2)
        df2 = as.list(df2)
        for (n in names(df2))
            df2[[n]] = list(df2[[n]])
        if (length(R) > 0 && !grepl("^[0-9]+$", R[1]))
            df2$.rownames = R
        attr(df2, "nrow") = nr
        }

    # Handle NULL.
    if (is.null(df1))
        return(df2)
    if (is.null(df2))
        return(df1)

    # rbind df2 to df1 by extending each sublist of df1 by the corresponding
    # sublist of df2.
    if (any(names(df1) == ".rownames") != any(names(df2) == ".rownames"))
        stop("rbind.fast: one but not both data frames have row names")
    for (n in names(df2)) # Use df2 in case df1 is NULL
        df1[[n]] = c(df1[[n]], df2[[n]])
    attr(df1, "nrow") = attr(df1, "nrow") + attr(df2, "nrow")
    return(df1)
    }

################################################################################
# Convert the list returned by rbind.fast back into the appropriate data frame.
#
# Arguments:
#   df: List returned by rbind.fast(), or a data frame.
#   stringsAsFactors: passed to as.data.frame().
#
# Returns: a data frame corresponding to df.  If df is already a data frame, it
# is returned, else the list is collapsed back into a data frame.
#
# Note: if df is a list and has element ".rownames", these are made into row
# names of the returned data frame.
#
# Note: see rbind.fast().
################################################################################
rbind.fast.finish = function(df, stringsAsFactors=FALSE, verbose=FALSE)
    {
    if (is.list(df))
        {
        R = NULL
        if (any(names(df) == ".rownames"))
            {
            R = df$.rownames
            df$.rownames = NULL
            }
        for (n in names(df))
            {
            if (verbose)
                cat0("Doing column '", n, "'\n")
            df[[n]] = unlist(df[[n]], use.names=FALSE)
            }
        df = as.data.frame(df, row.names=R, stringsAsFactors=FALSE)
        }
    return(df)
    }

################################################################################
# Does do.call(rbind, <data frame list>) using rbind.fast to vastly speed it up.
#
# Arguments:
#   L: List of data frames to be rbound.
#   stringsAsFactors: passed to as.data.frame().
#
# Returns: a data frame containing all data frames in list L, bound together
# one below the other, i.e. the number of columns stays constant.
################################################################################
do.call.rbind.fast = function(L, stringsAsFactors=FALSE)
    {
    dfAll = NULL
    for (df in L)
        dfAll = rbind.fast(dfAll, df)
    return(rbind.fast.finish(dfAll, stringsAsFactors))
    }

################################################################################
# Save data in a global variable.
#   data: the data to be saved in the global variable.
#   globalVar: global variable name.
################################################################################
cacheData = function(data, globalVar)
    {
    assignGlobal(globalVar, data)
    }

################################################################################
# Retrieve the value of a global variable.
#   globalVar: global variable name.
# Return the data value that is stored in the global variable, or NULL if the global
# variable doesn't exist.
# Note: avoid using this function as it generally will return a copy of a very large
# object.  Instead, refer to the global variable directly by its name.  This is only
# used when the name is not known to the caller except at run time via a variable
# containing the name.
################################################################################
getCachedData = function(globalVar)
    {
    if (!exists(globalVar))
        return(NULL)
    return(get(globalVar))
    }

################################################################################
# Read a file into a data frame and then save the data frame in a global variable.
# If the global variable already exists, do nothing under the assumption that the
# file has already been read and saved in it.
#   filename: name of file to read.
#   globalVar: name of global variable in which to save the data frame.
#   rownameColumn: If not NA, this must be the name of a column to add as the first
#       column of the data frame, with values for the column taken from the row names
#       of the data frame (the ... argument would have argument row.names in it).
#   header: for read.table.
#   stringsAsFactors: for read.table.
#   ...: additional arguments for read.table()
################################################################################
readAndCacheFile = function(filename, globalVar, rownameColumn=NA, header=TRUE,
    stringsAsFactors=FALSE, ...)
    {
    if (!exists(globalVar))
        {
        df = read.table(filename, header=header, stringsAsFactors=stringsAsFactors, ...)
        if (!is.na(rownameColumn))
            {
            df = data.frame(xxx=rownames(df), df, stringsAsFactors=stringsAsFactors)
            colnames(df)[1] = rownameColumn
            }
        assignGlobal(globalVar, df)
        }
    }

################################################################################
# Return the current value of a specified global variable, or if it doesn't exist, call
# readAndCacheFile() with the specified arguments to read data from the file and store
# it in the global variable.
#   filename: name of file to read.
#   globalVar: name of the global variable in which to store the file data.
#   rownameColumn: see readAndCacheFile().
#   header: for read.table.
#   stringsAsFactors: for read.table.
#   ...: additional arguments for read.table()
# Return the global variable's value, which is the data read from the file.
# Note: avoid using this function as it generally will return a copy of a very large
# object.  Instead, refer to the global variable directly by its name.  This is only
# used when the name is not known to the caller except at run time via a variable
# containing the name.
################################################################################
readAndGetCachedData = function(filename, globalVar, rownameColumn=NA, header=TRUE,
    stringsAsFactors=FALSE, ...)
    {
    if (!exists(globalVar))
        readAndCacheFile(filename, globalVar, rownameColumn, header, stringsAsFactors, ...)
    return(get(globalVar))
    }

################################################################################
# Compute explained variance from 1-way ANOVA results by decomposing MSH and MSE.
# In a 1-way ANOVA, the mean square value is not an estimate of the explained variance,
# but is a combination of it and the within-group variance: MSH = VarE + n*VarH, where
# n = number of replicates in the group.  MSE is an estimate of VarE.  Therefore, VarH
# can be estimated as (MSH-MSE)/n.  If the estimate is negative, it is set to 0.
# Arguments:
#   anovaResult: result of anova() on a single-factor model.
# Returns: list with these elements:
#   varH: estimated variance due to the single factor.
#   varE: estimated error variance (MSE from ANOVA).
#   varT: estimated total variance = varH + varE
#   frac: fraction of variance that is explained = varH/varT
################################################################################
getANOVA1varianceExplained = function(anovaResult)
    {
    if (nrow(anovaResult) != 2)
        stop("getANOVA1varianceExplained requires 1-way ANOVA results")
    n = (sum(anovaResult[,1])+1)/(anovaResult[1,1]+1)
    MSH = anovaResult[1,3]
    varE = anovaResult[2,3]
    varH = (MSH-varE)/n
    if (varH < 0)
        varH = 0
    varT = varH+varE
    frac = varH/varT
    return(list(varH=varH, varE=varE, varT=varT, frac=frac))
    }

################################################################################
# Uncentered correlation (cosine similarity) of two vectors.
################################################################################
cosv = function(v1, v2)
    {
    v1 = as.numeric(v1)
    v2 = as.numeric(v2)
    return(sum(v1*v2)/(sqrt(sum(v1*v1)*sum(v2*v2))))
    }

################################################################################
# Apply cosv to a whole matrix or data frame.  If df is MxN, the result is NxN.
################################################################################
cosvDf = function(df)
    {
    m = t(df)
    mprod = m %*% t(m)
    mdiag = diag(mprod)
    return(mprod/sqrt(mdiag %*% t(mdiag)))
    }

################################################################################
# Apply cosv to two matrices or data frames of size MxN and MxK, to produce a resulting
# distance matrix of size NxK.
################################################################################
cosvDfPair = function(df1, df2)
    {
    m1 = t(df1)
    m2 = as.matrix(df2)
    mprod = m1 %*% m2
    m1dim = 1:nrow(m1)
    m2dim = 1:ncol(m2)
    m1magSqrd = sapply(m1dim, function(x) sum(m1[x,]^2))
    m2magSqrd = sapply(m2dim, function(x) sum(m2[,x]^2))
    return(mprod/sqrt(m1magSqrd %*% t(m2magSqrd)))
    }

################################################################################
# Uncentered correlation that automatically detects argument classes and calls the
# appropriate function above.
################################################################################
cosu = function(a1, a2=NULL)
    {
    if (is.vector(a1) && is.vector(a2))
        return(cosv(a1, a2))
    if (is.vector(a1) || is.matrix(a1) || is.data.frame(a1))
        {
        if (is.null(a2))
            return(cosvDf(a1))
        if (is.vector(a1) || is.matrix(a1) || is.data.frame(a1))
            return(cosvDfPair(a1, a2))
        }
    stop("Unable to do uncentered correlation on arg types: ", class(a1), " and ", class(a2))
    }

################################################################################
# Do cor() but if std. dev. of x or y is 0, return 0.  Support x and/or y being a matrix.
################################################################################
cor.safe = function(x, y, ...)
    {
    Nx = ifelse(is.vector(x), length(x), nrow(x))
    Ny = ifelse(is.vector(y), length(y), nrow(y))
    if (Nx != Ny)
        R = cor(x, y, ...)
    else
        {
        # Modify columns that have std. dev. = 0 so they don't, then take cor(), then
        # replace result with 0 for columns that were modified.
        if (is.vector(x))
            {
            x.use0 = (sd(x, na.rm=TRUE) == 0)
            if (x.use0)
                x[] = 1:length(x)
            }
        else
            {
            x.use0 = (apply(x, 2, sd, na.rm=TRUE) == 0)
            x[,x.use0] = 1:nrow(x)
            }

        if (is.vector(y))
            {
            y.use0 = (sd(y, na.rm=TRUE) == 0)
            if (y.use0)
                y[] = 1:length(y)
            }
        else
            {
            y.use0 = rep(FALSE, ncol(y))
            y[,y.use0] = 1:nrow(y)
            }

        R = cor(x, y, ...)

        if (is.vector(x))
            {
            if (x.use0)
                {
                if (is.vector(y))
                    R = 0
                else
                    R[] = 0
                }
            }
        else if (any(x.use0))
            {
            R[x.use0,] = 0
            }

        if (is.vector(y))
            {
            if (y.use0)
                {
                if (is.vector(x))
                    R = 0
                else
                    R[] = 0
                }
            }
        else if (any(y.use0))
            {
            R[,y.use0] = 0
            }
        }
    return(R)
    }

################################################################################
# Partial Pearson correlation.
# From Biometry, Sokal and Rohlf, 3rd ed., 1995, pg. 649, the partial correlation
# of x and y with z held constant is done as in this function.
################################################################################
partialCor = function(x, y, z, method=c("pearson", "spearman"),
    use=c("everything", "all.obs", "complete.obs", "na.or.complete", "pairwise.complete.obs"))
    {
    r_xy = cor(x, y, method=method[1], use=use[1])
    r_xz = cor(x, z, method=method[1], use=use[1])
    r_yz = cor(y, z, method=method[1], use=use[1])
    return((r_xy-r_xz*r_yz)/sqrt((1-r_xz^2)*(1-r_yz^2)))
    }

################################################################################
# Perform correlation between x and y, or between rows of x.  See function cor() in R
# help for description of arguments.  This function supports additional methods beyond
# what cor() supports:
#   uncentered: use cosu() above instead of cor().
#   abs.uncentered: abs(cosu(x, y))
#   abs.(other): abs(cor(x, y, method=(other)))
# Note that currently cosu() does not support the "use" argument.
################################################################################
cor.expanded = function(x, y=NULL, method="pearson", use="everything")
    {
    doAbs = FALSE
    if (grepl("^abs.", method))
        {
        doAbs = TRUE
        method = sub("^abs.", "", method)
        }
    if (method == "uncentered")
        corVal = cosu(x, y)
    else
        corVal = cor(x, y, method=method, use=use)
    if (doAbs)
        corVal = abs(corVal)
    return(corVal)
    }

################################################################################
# Compute root mean square error between two equal-sized vectors.
################################################################################
rmse = function(V1, V2)
    {
    if (!is.vector(V1) || !is.vector(V2))
        stop("Both V1 and V2 must be vectors")
    if (length(V1) != length(V2))
        stop("V1 and V2 must be equal-length vectors")
    if (length(V1) == 0)
        stop("V1 and V2 must be non-0-length vectors")
    e = sqrt(mean((V1-V2)^2))
    return(e)
    }

################################################################################
# Wilson Score confidence interval for binomial distributed Ns success of N trials.
# N and Ns can be equal-length vectors.  conf.level is confidence level, 0..1.
# Returns list with mid=midpoint of confidence interval, pm=plus/minus midpoint
# either side of mid, f=pm/mid.  mid, pm, and f are vectors same size as N and Ns.
################################################################################
Wilson_CI = function(N, Ns, conf.level=0.95)
    {
    ind = !is.na(N) & N != 0 & !is.na(Ns)
    alpha = 1-conf.level
    z = qnorm(1-alpha/2)
    zz = z*z
    Nf = N[ind] - Ns[ind]
    m = 1/(N[ind]+zz)
    pm = m*z*sqrt(Ns[ind]*Nf/N[ind]+zz/4)
    mid = m*(Ns[ind]+zz/2)
    f = pm/mid
    mid.all = rep(NA, length(N))
    pm.all = mid.all
    f.all = mid.all
    mid.all[ind] = mid
    pm.all[ind] = pm
    f.all[ind] = f
    return(list(mid=mid.all, pm=pm.all, f=f.all))
    }

################################################################################
# Solve the binomial distribution for the value of probability 'prob' required
# to make the distribution value for some given 'q' and 'size' equal a value 'p'.
#
# Arguments:
#   p: return value of pbinom() to be sought, may be a vector.
#   q: value of 1st argument 'q' of pbinom(), may be a vector.
#   size: value of 2nd argument 'size' of pbinom(), may be a vector.
#   lower.tail: value of 4th argument 'lower.tail' of pbinom(), length 1.
#   Niter: number of iterations to perform, more for more accurate result, length 1.
#   side: "high" to return a value for the 3rd argument 'prob' of pbinom() that
#       results in a pbinom() return value > p, "low" for < p, length 1 (or 2,
#       2nd ignored).
#
# Returns: value that can be used for 3rd argument 'prob' of pbinom() to get a
# result close to p.
#
# Note: All arguments that may be a vector are recycled to the length of the
# longest one.
################################################################################
findBinomProb = function(p, q, size, lower.tail=TRUE, Niter=20, side=c("high", "low"))
    {
    N = max(length(p), length(q), length(size))
    p = rep(p, length.out=N)
    q = rep(q, length.out=N)
    size = rep(size, length.out=N)
    if (length(lower.tail) != 1) stop("lower.tail length must be 1")
    if (length(Niter) != 1) stop("Niter length must be 1")
    if (!length(side) %in% 1:2) stop("side length must be 1 or 2")

    # Start by using all values of 'prob' from 0 to 1 by steps of 0.1 and find the
    # two that the desired 'prob' lies between.
    probs = seq(0, 1, by=0.1)
    mtx = sapply.matrix(probs, function(prob) pbinom(q, size, prob, lower.tail))
    # Note: mtx > vector returns logical matrix of same size, COLUMNS of mtx are compared to vector.

    # For each case 1..N, the matrix row starts large and gets smaller (lower.tail=TRUE)
    # or starts small and gets larger (lower.tail=FALSE).  Find the first prob
    # value where result <= p (lower.tail=TRUE) or where result >= p (lower.tail=FALSE).
    if (lower.tail)
        idx = apply(mtx <= p, 1, function(V) which(V)[1])
    else
        idx = apply(mtx >= p, 1, function(V) which(V)[1])

    # Set the left-side and right-side probs[] values that straddle the point
    # we are looking for.
    if (lower.tail)
        if (idx == 0) stop("Unexpected left side index, is p >= 1?")
    else
        if (idx == length(probs)) stop("Unexpected left side index, is p <= 0?")
    left = probs[idx-1]
    right = probs[idx]

    # Now iterate between the two straddle points by taking the midpoint and
    # calculating pbinom() there, then replace one of the straddle points with
    # the midpoint.
    for (i in 1:Niter)
        {
        mids = (left+right)/2
        V = pbinom(q, size, mids, lower.tail)
        if (lower.tail)
            ind = (V <= p)
        else
            ind = (V >= p)
        right[ind] = mids[ind]
        left[!ind] = mids[!ind]
        }

    if ((side[1] == "high") == lower.tail)
        return(left)
    return(right)
    }

################################################################################
# Compute a distance matrix giving distance between each pair of rows of x.
#   x: a numeric matrix or data frame.  Currently, NA values are not allowed.
#   method: distance measure used, one of:
#       euclidean: Usual Euclidean distance between the two row vectors.
#       maximum: Maximum of difference between components of the two row vectors.
#       manhattan: "Taxicab" distance, sum of absolute difference between components.
#       canberra: sum(|x_i - y_i| / |x_i + y_i|)
#       minkowski: pth root of the sum of the pth powers of the differences of components.
#       pearson: 1 - pearson correlation of the two row vectors.
#       spearman: 1 - spearman correlation of the two row vectors.
#       kendall: 1 - kendall correlation of the two row vectors.
#       uncentered: 1 - uncentered correlation of the two row vectors.
#       abs.pearson: 1 - abs(pearson correlation)
#       abs.spearman: 1 - abs(spearman correlation)
#       abs.kendall: 1 - abs(kendall correlation)
#       abs.uncentered: 1 - abs(uncentered correlation)
################################################################################
dist.mtx = function(x, method="euclidean", p=3)
    {
    distFuncMethods = c("euclidean", "maximum", "manhattan", "canberra", "minkowski")
    if (method %in% distFuncMethods)
        return(as.matrix(dist(x, method=method, p=p)))
    return(1 - cor.expanded(t(x), method=method))
    }
distMethods = c( # kendall omitted because extremely slow
    "euclidean",    "maximum",      "manhattan",    "canberra",     "minkowski",
    "pearson",      "spearman",     "uncentered",   "abs.pearson",  "abs.spearman",
    "abs.uncentered")

################################################################################
# Calculate the trace of a square matrix.
#
# Arguments:
#   m: a square matrix.
#
# Returns: Trace of m, tr(m) = sum(diag(m))
################################################################################
trace.mtx = function(m)
    {
    if (class(m) != "matrix") stop("trace.mtx: m is not a matrix")
    if (dim(m)[1] != dim(m)[2]) stop("trace.mtx: m is not a square matrix")
    return(sum(diag(m)))
    }

################################################################################
# Calculate the Frobenius distance between two equal-sized matrices.
#
# Arguments:
#   m1, m2: the two matrices.
#
# Returns: Frobenius distance between m1 and m2, sqrt(trace((m1-m2)*t(m1-m2)))
################################################################################
frobenius.mtx = function(m1, m2)
    {
    if (class(m1) != "matrix") stop("frobenius.mtx: m1 is not a matrix")
    if (class(m2) != "matrix") stop("frobenius.mtx: m2 is not a matrix")
    if (!all(dim(m1) == dim(m2))) stop("frobenius.mtx: m1 and m2 are not the same size")
    d = m1 - m2
    # D = sqrt(trace.mtx(d %*% t(d)))
    # If you work out the math, the following is equivalent, and simpler.
    D = sqrt(sum(d*d))
    return(D)
    }

################################################################################
# Calculate the Frobenius distance between every pair in two different sets of
# equal-sized matrices.
#
# Arguments:
#   a1, a2: two arrays whose 2nd and 3rd dimensions are equal.
#
# Returns: matrix of size I1 x I2, where I1 = first dimension of a1, I2 = first
# dimension of a2, containing the Frobenius distance between each pair (i,j) of
# matrices (a1[i,,], a2[j,,]).
################################################################################
frobenius.arrays = function(a1, a2)
    {
    if (class(a1) != "array" || length(dim(a1)) != 3) stop("frobenius.arrays: a1 is not a 3D array")
    if (class(a2) != "array" || length(dim(a2)) != 3) stop("frobenius.arrays: a2 is not a 3D array")
    if (!all(dim(a1)[-1] == dim(a2)[-1])) stop("frobenius.arrays: a1 and a2 do not have the same 2nd and 3rd dimensions")
    I1 = dim(a1)[1]
    I2 = dim(a2)[1]
    # R seems slightly faster when a nested sapply(sapply( has the larger number
    # of iterations in the inner sapply
    if (I1 > I2)
        mtx = sapply(1:I2, function(i2)
            {
            d2 = a2[i2,,]
            return(sapply(1:I1, function(i1) return(sqrt(sum((a1[i1,,] - d2)^2)))))
            })
    else
        mtx = t(sapply(1:I1, function(i1)
            {
            d1 = a1[i1,,]
            return(sapply(1:I2, function(i2) return(sqrt(sum((d1 - a2[i2,,])^2)))))
            }))
    return(mtx)
    }

################################################################################
# Compress a matrix into a dataframe column.
#
# Arguments:
#   df: data frame.
#   mtx: matrix with rows sorted in the same order as df rows, with column names.
#   colCol: name of a column of df that may or may not yet exist in df.
#   dataCol: name of a column to be added to df, to contain values from mtx.
#
# Returns: nothing.  Caller's df is modified directly using "<<-" operator.
#
# Details:
# The first time this is called with a specific df, column 'colCol' does not
# exist in the data frame, and nrow(df) == nrow(mtx).  Each row of df is then
# replicated nrow(mtx) times, and 'colCol' is added to df and its values in the
# now-expanded df are colnames(mtx) replicated nrow(mtx) times, so that the
# first ncol(mtx) rows of df are identical except that new column 'colCol' has
# colnames(mtx) in it.  nrow(df) is now nrow(mtx)*ncol(mtx).  Subsequently when
# this is called with that df, column 'colCol' already exists and contains
# values of colnames(mtx), and nrow(df) == nrow(mtx)*ncol(mtx).
#
# After the above is done, new column 'dataCol' is added to df, and its contents
# are the contents of mtx, taken one row at a time, so that data in column X is
# placed in rows of df where df[, colCol] == "X".
################################################################################
moveMtxIntoDf = function(df, mtx, colCol, dataCol)
    {
    M = nrow(mtx)
    N = ncol(mtx)
    repMtxColNames = rep(colnames(mtx), M)
    if (!colCol %in% colnames(df))
        {
        if (nrow(df) != M)
            stop("First call must have nrow(df) == nrow(mtx)")
        df <<- df[rep(1:M, each=N),]
        df[, colCol] <<- repMtxColNames
        }
    else
        {
        if (nrow(df) != M*N)
            stop("After first call, must have nrow(df) == nrow(mtx)*ncol(mtx)")
        if (!all(df[, colCol] == repMtxColNames))
            stop("After first call, must have colCol containing replicated colnames(mtx)")
        }

    df[, dataCol] <<- c(t(mtx))
    }

################################################################################
# Create a matrix from two dataframe columns, inverse of moveMtxIntoDf.
#
# Arguments:
#   df: data frame.
#   colCol: name of a column of df containing the matrix column names.
#   dataCol: name of a column of df containing the matrix values.
#
# Returns: the created matrix.
#
# Details:
# A matrix is created whose column names are unique(df[,colCol]) and whose total
# size is equal to nrow(df).  The matrix values are taken from df[, dataCol],
# with the values in matrix column X being df[df[,colCol] == "X", dataCol].
################################################################################
getMtxFromDf = function(df, colCol, dataCol)
    {
    if (!colCol %in% colnames(df))
        stop("colCol must be a df column name")
    if (!dataCol %in% colnames(df))
        stop("dataCol must be a df column name")
    mtxColNames = unique(df[,colCol])
    N = length(mtxColNames)
    M = round(nrow(df)/N)
    if (M*N != nrow(df))
        stop("length(unique(df[,colCol])) must evenly divide nrow(df)")
    if (!all(df[, colCol] == rep(mtxColNames, M)))
        stop("colCol must contain replicated unique(df[,colCol])")
    mtx = matrix(df[,dataCol], nrow=M, ncol=N, dimnames=list(NULL, mtxColNames))
    return(mtx)
    }

################################################################################
# Insert one or more columns into data frame "df, preserving its row names.
#
# Arguments:
#   df: a data frame, possibly with 0 rows, or NULL.
#   newColumns: several possibilities:
#       - a data frame: all of its columns are inserted into df.  If df is not
#           NULL and doesn't have 0 rows, then newColumns must have the same number
#           of rows as df, or it can have 0 rows, in which case its columns are
#           added with NA values in the rows.  The column names of newColumns, if
#           any, become the names of the new columns of df if colNames argument is
#           NULL.  The row names of NewColumns, if any, become the new row names
#           of df if rowNames argument is an integer index of this newColumns
#           element.
#       - a scalar (vector of length 1): this value is inserted into every row of a
#           new column of df.  If df is NULL or has 0 rows, the new data frame has
#           one row with one column added with the scalar as its contents.  The
#           colNames argument should be specified to provide a name for the new
#           column.  The names of the vector, if any, become the names of the new
#           rows of df if rowNames argument is an integer index of this newColumns
#           element
#       - a vector (of length > 1): this is inserted as a new column into df.  If
#           df is not NULL and doesn't have 0 rows, then the length of newColumns
#           must equal the number of rows of df.  If df is NULL or has 0 rows, the
#           new data frame has one column added with the vector as its contents.
#           The colNames argument should be specified to provide a name for the new
#           column.  The names of the vector, if any, become the names of the new rows
#           of df if rowNames argument is an integer index of this newColumns element.
#       - a list: each element of the list must be either a data frame or vector and
#           is handled as described above for the other two newColumns possibilities.
#           If the list has names, those names become the names of new columns of df
#           if colNames argument is NULL and the named argument is a vector.
#       - NULL: this is similar to a value of NA (vector of length 1 containing NA),
#           except that if df is NULL or has 0 rows, the returned data frame will have
#           0 rows and will have a new column whose name is determined by the colNames
#           argument.  Use this to add a column to a data frame without adding any data
#           yet.
#   colNames: a vector of names for the new columns that are added to df, used in the
#       order the columns appear in the newColumns argument.  If NULL, column names
#       are taken from the newColumns argument when possible.
#   rowNames: several possibilities:
#       - a vector of names for the rows of df, of the same length as the number of
#           rows in df, or if df is NULL or has 0 rows, of the same length as the new
#           data provided in the newColumns argument.
#       - an integer.  In this case, the integer identifies which of the newColumns
#           arguments should be used to supply row names.  If newColumns is not a list,
#           the integer would be 1, but if it is a list, the integer indexes the list.
#       - NA: Row names of the returned data frame are set to NULL.
#       - NULL: The existing row names of df are not changed.
#   beforeCol: the column name or number before which to insert the new column(s).
#       If NULL, the argument is ignored.
#   afterCol: the column name or number after which to insert the new column(s), if
#       beforeCol is NULL.  If both this and beforeCol are NULL, the new columns are
#       added after the existing columns of df.
#   stringsAsFactors: passed along to any function used that has this argument.
#
# Returns: the new data frame with new columns added.
#
# Examples:
#   1. To add to df two new columns named "clusters" and "degree" containing NA,
#       after existing column "ILs":
#          df = insertDfColumns(df, newColumns=list(clusters=NA, degree=NA), afterCol="ILs")
################################################################################
insertDfColumns = function(df, newColumns=NA, colNames=NULL, rowNames=NULL,
    beforeCol=NULL, afterCol=NULL, stringsAsFactors=FALSE)
    {
    # Make sure df is a data frame or NULL.
    if (!is.null(df) && !is.data.frame(df)) stop("insertDfColumns: df argument is not a data frame or NULL")

    # If newColumns is not a list, make it a list with one element.
    if (!is.list(newColumns))
        newColumns = list(newColumns)

    # Record the initial number of columns in df.  New columns are initially added
    # after these, and will be moved to the correct position later.  If df is NULL,
    # use 0.
    NcolsInitial = ncol(df)
    if (is.null(df))
        NcolsInitial = 0

    # Process each element of the newColumns list.
    for (i in 1:length(newColumns))
        {
        newColName = names(newColumns)[i]
        newCol = newColumns[[i]]

        # Record the current number of columns in df, before columns are added.
        NcolsBeforeAdd = ncol(df)
        if (is.null(df))
            NcolsBeforeAdd = 0

        # Case 1: newColumns is a data frame.
        if (is.data.frame(newCol))
            {
            if (is.null(df))
                df = newCol
            else if (nrow(df) == 0 || nrow(newCol) == 0 || nrow(df) == nrow(newCol))
                {
                if (nrow(df) == 0 && nrow(newCol) > 0)
                    df[1:nrow(newCol),] = NA
                else if (nrow(df) > 0 && nrow(newCol) == 0)
                    newCol[1:nrow(df),] = NA
                df = cbind(df, newCol, stringsAsFactors=stringsAsFactors)
                }
            else stop("insertDfColumns: nrow(newColumns)=", nrow(newCol), " not equal to nrow(df)=", nrow(df))
            }

        # Case 2/3: newColumns is a vector, of length 1 or > 1.
        else if (is.vector(newCol))
            {
            if (length(newCol) == 0) stop("insertDfColumns: newColumns argument is vector of length 0")
            if (is.null(df))
                df = data.frame(newCol, stringsAsFactors=stringsAsFactors)
            else if (nrow(df) == 0 || nrow(df) == length(newCol))
                {
                if (nrow(df) == 0)
                    df[1:length(newCol),] = NA
                df = cbind(df, newCol, stringsAsFactors=stringsAsFactors)
                }
            else stop("insertDfColumns: length(newColumns)=", length(newCol), " not equal to nrow(df)=", nrow(df))

            # Add new column name = newColName if it isn't NULL and if colNames is NULL.
            if (is.null(colNames) && !is.null(newColName))
                colnames(df)[ncol(df)] = newColName
            }

        # Case 4: newColumns in NULL.
        else if (is.null(newCol))
            {
            newCol = as.data.frame(matrix(NA, nrow=0, ncol=1), stringsAsFactors=stringsAsFactors)
            if (is.null(df))
                df = newCol
            else if (nrow(df) == 0)
                df = cbind(df, newCol, stringsAsFactors=stringsAsFactors)
            else
                df = cbind(df, NA, stringsAsFactors=stringsAsFactors)
            }

        # Else newColumns is invalid.
        else stop("insertDfColumns: invalid newColumns argument class: ", class(newCol))

        # Do some sanity checks.
        if (is.null(df)) stop("insertDfColumns: programming error, unexpected NULL df")
        NcolsAfterAdd = ncol(df)
        numNewCols = NcolsAfterAdd - NcolsBeforeAdd
        if (numNewCols < 1) stop("insertDfColumns: programming error, expected new columns added")

        # Add column names to the new columns from colNames if it isn't NULL.
        if (!is.null(colNames))
            {
            if (!is.character(colNames)) stop("insertDfColumns: colNames argument is not character class")
            if (length(colNames) < numNewCols) stop("insertDfColumns: colNames argument length is too small")
            newColNames = colNames[1:numNewCols]
            colNames = colNames[-(1:numNewCols)]
            colnames(df)[(NcolsBeforeAdd+1):ncol(df)] = newColNames
            }
        }

    # Add row names to df from rowNames if it isn't NULL.
    if (is.character(rowNames))
        {
        if (length(rowNames) != nrow(df))
            stop("insertDfColumns: rowNames argument length=", length(rowNames), " not equal to nrow(df)=", nrow(df))
        rownames(df) = rowNames
        }
    else if (is.numeric(rowNames) && length(rowNames) == 1)
        {
        idx = as.integer(rowNames)
        if (idx < 1 || idx > length(newColumns))
            stop("insertDfColumns: invalid value for numeric rowNames argument: ", rowNames)
        newCol = newColumns[[idx]]
        newRowNames = c()
        if (is.data.frame(newCol))
            newRowNames = rownames(newCol)
        else if (is.vector(newCol))
            newRowNames = names(newCol)
        if (length(newRowNames) != nrow(df))
            stop("insertDfColumns: rowNames argument indexes nColumns argument with ",
                length(newRowNames), " row names not equal to nrow(df)=", nrow(df))
        rownames(df) = newRowNames
        }
    else if (length(rowNames) == 1 && is.na(rowNames))
        rownames(df) = NULL
    else if (!is.null(rowNames))
        stop("insertDfColumns: invalid rowNames argument class: ", class(rowNames), " or length: ", length(rowNames))

    # Move the new columns to the specified position.
    moveBefore = NULL # Numeric column index.  NULL means to not move the columns, leave them at the end of df.
    if (!is.null(beforeCol))
        {
        if (!is.numeric(beforeCol))
            idx = which(beforeCol == colnames(df))[1]
        if (is.numeric(idx) && length(idx) == 1 && !is.na(idx))
            moveBefore = as.integer(idx)
        else
            stop("insertDfColumns: invalid beforeCol argument: ", beforeCol, " No such column.")
        }
    else if (!is.null(afterCol))
        {
        if (!is.numeric(afterCol))
            idx = which(afterCol == colnames(df))[1]
        if (is.numeric(idx) && length(idx) == 1 && !is.na(idx))
            moveBefore = as.integer(idx) + 1
        else
            stop("insertDfColumns: invalid afterCol argument: ", afterCol, " No such column.")
        }
    if (!is.null(moveBefore) && (moveBefore > NcolsInitial))
            moveBefore = NULL
    if (!is.null(moveBefore))
        {
        NcolsFinal = ncol(df)
        NnewCols = NcolsFinal - NcolsInitial
        if (NnewCols < 1)
            stop("insertDfColumns: programming error, expected some new columns")
        oldColIdxs = 1:NcolsInitial
        newColIdxs = (NcolsInitial+1):NcolsFinal
        if (moveBefore <= 1)
            df = df[, c(newColIdxs, oldColIdxs)]
        else
            df = df[, c(1:(moveBefore-1), newColIdxs, moveBefore:NcolsInitial)]
        }
    return(df)
    }

################################################################################
# Append columns of data to data frame "df, preserving its row names.  Careful: this
# needs to work even if the data frame has no rows!!!!
################################################################################
appendColumns = function(df, columns)
    {
    return(insertDfColumns(df, columns))
    }

################################################################################
# Append rows of data to data frame "df, preserving its column names.  Careful: this
# needs to work even if the data frame has no columns!!!!
################################################################################
appendRows = function(df, rows)
    {
    if (ncol(df) == 0)
        {
        df = as.data.frame(matrix(NA, nrow=nrow(df)+1, ncol=0,
            dimnames=list(c(rownames(df), rownames(rows)), c())))
        }
    else
        {
        if (is.vector(rows))
            rows = as.matrix(rows, nrow=1)
        colnames(rows) = colnames(df)
        if (nrow(df) == 0)
            df = as.data.frame(rows, stringsAsFactors=FALSE)
        else
            df = rbind(df, rows)
        }
    return(df)
    }

################################################################################
# Convert data frame, matrix, or array indexes (names or numbers) into index
# numbers.
#
# Arguments:
#   idxs: list or vector of index names and/or numbers.
#   x: a data frame, matrix, or array containing 'idxs' in its index names or
#       numbers, or a character vector of index names in order.
#   dim: which dimension of the data frame, matrix, or array do 'idxs' belong
#       to?  1 for first dimension (rownames), 2 for second (colnames), etc.
#
# Returns: vector of integer index numbers equal in length to length(idxs)
################################################################################
dimIdxsToNumber = function(idxs, x, dim=2)
    {
    if (is.data.frame(x) || is.matrix(x) || is.array(x))
        {
        dim = as.integer(dim)
        if (is.na(dim) || dim < 1 || dim > length(dim(x)))
            stop("Bad dim value")
        x = dimnames(x)[[dim]]
        }
    if (!is.character(x)) stop("bad x value, character vector of index ", dim, " names required")

    if (isNonListVector(idxs) && (is.character(idxs) || is.numeric(idxs)))
        idxs = as.list(idxs)
    if (is.data.frame(idxs) || !is.list(idxs))
        stop("bad idxs value, must be character or numeric vector or list")

    isChar = sapply(idxs, function(V) is.character(V) && !is.matrix(V))
    isNum = sapply(idxs, function(V) is.numeric(V) && !is.matrix(V))
    unknown = !isChar & !isNum
    if (any(unknown))
        stop("Unknown idxs element type: ", paste(idxs[unknown], collapse=","))

    badLen = sapply(idxs, function(V) length(V) != 1)
    if (any(badLen))
        stop("bad idxs value, must have one index per list element, at idxs[", paste(which(badLen), collapse=","), "]")

    missing = sapply(idxs[isChar], function(V) !V %in% x)
    if (any(missing))
        {
        isCharNum = sapply(idxs[isChar][missing], function(V) grepl("^[0-9]+$", V))
        isChar[isChar][missing][isCharNum] = FALSE
        isNum[isChar][missing][isCharNum] = TRUE
        missing[missing][isCharNum] = FALSE
        if (any(missing))
            stop("No such idxs name(s): ", paste(idxs[isChar][missing], collapse=","))
        }

    idxs.int = rep(NA, length(idxs))
    idxs.int[isChar] = match(idxs[isChar], x)
    idxs.int[isNum] = as.integer(idxs[isNum])
    outOfRange = idxs.int < 1 | idxs.int > length(x)
    if (any(outOfRange))
        stop("idxs are out of range: ", paste(idxs[outOfRange], collapse=","))

    return(idxs.int)
    }

################################################################################
# Convert data frame or matrix row indexes (names or numbers) to row numbers.
#
# Arguments:
#   rows: vector or list of row index names or numbers.
#   x: a data frame or matrix providing the row names, or a character vector
#       of row names in row order.
#
# Returns: vector of integer row numbers equal in length to length(rows)
################################################################################
rowsToNumber = function(rows, x)
    {
    return(dimIdxsToNumber(rows, x, 1))
    }

################################################################################
# Convert data frame or matrix column indexes (names or numbers) to column numbers.
#
# Arguments:
#   cols: vector or list of column index names or numbers.
#   x: a data frame or matrix providing the column names, or a character vector
#       of column names in column order.
#
# Returns: vector of integer column numbers equal in length to length(col)
################################################################################
colsToNumber = function(cols, x)
    {
    return(dimIdxsToNumber(cols, x, 2))
    }

################################################################################
# Convert two or more vectors, identical in length, of indexes into x (name or
# numeric indexes, one vector per dimension of x, where x must be a matrix,
# data frame, or array) into an N-column matrix of index numbers, where N is
# the number of vectors = dimension of x.  This matrix can be used to index
# into x using a single statement, e.g. x[getIdxMtx(x, V1, V2)] = 99
#
# Arguments:
#   x: a data frame, matrix, or array to be indexed into.
#   ...: N vectors, identical in length, where N = length(dim(x)).
#
# Returns: integer M x N matrix, where M = length(any argument vector), which
# can directly index x.
################################################################################
getIdxMtx = function(x, ...)
    {
    if (!is.data.frame(x) && !is.matrix(x) && !is.array(x))
        stop("x must be a data frame, matrix, or array")
    L = list(...)
    N = length(dim(x))
    if (length(L) != N)
        stop("Number of vectors supplied must equal length(dim(x))")
    M = length(L[[1]])
    for (i in 1:N)
        if (length(L[[i]]) != M)
            stop("All vectors must be identical in length")

    mtx = matrix(0, nrow=M, ncol=N)
    for (i in 1:N)
        mtx[,i] = dimIdxsToNumber(L[[i]], x, dim=i)

    return(mtx)
    }

################################################################################
# Move specified columns of matrix or data frame to specified new position.
#
# Arguments:
#   x: the data frame or matrix.
#   cols: names or numbers of columns to move, in the order that they are
#       to appear after being moved.
#   afterCol: name or number of column to move the columns after.
#   beforeCol: name or number of column to move the columns before.
#       (If both afterCol and beforeCol are NULL, beforeCol is taken as the
#       lowest-numbered column of the columns specified by 'cols', which is
#       useful if a subset of columns is being sorted, since 'cols' in that
#       case can be column names sorted using order().
#
# Returns: modified data frame or matrix.
#
# Example of sorting the df columns whose names are in "sc" by the values in row "sr":
#   df = data.frame(a=100:110, b=0:10, c=10:0, d=15:5, e=900:910)
#   df
#   sc = c("b", "c", "d")
#   sr = 9
#   df = moveColumns(df, sc[order(df[sr, sc])])
#   df
################################################################################
moveColumns = function(x, cols, afterCol=NULL, beforeCol=NULL)
    {
    # Check cols argument.
    if (!is.numeric(cols))
        {
        missingCols = cols[!cols %in% colnames(x)]
        if (length(missingCols) > 0)
            stop("moveColumns: No such columns: ", paste(missingCols, collapse=" "))
        cols = match(cols, colnames(x))
        }

    # Check afterCol and beforeCol arguments.
    if (is.null(afterCol) && is.null(beforeCol))
        beforeCol = min(cols)
    if (!is.null(afterCol) && !is.null(beforeCol))
        stop("moveColumns: Neither afterCol nor beforeCol is NULL")
    before = FALSE
    col = afterCol
    if (!is.null(beforeCol))
        {
        before = TRUE
        col = beforeCol
        }
    if (length(col) != 1)
        stop("moveColumns: expected exactly one column for afterCol/beforeCol, got: ", length(col))
    col = colsToNumber(col, x)
    if (before)
        col = col-1 # Move AFTER column 'col'

    # Now do the work.
    x.before = NULL
    if (col > 0)
        x.before = x[, setdiff(1:col, cols), drop=FALSE]
    x.after = NULL
    if (col < ncol(x))
        x.after = x[, setdiff((col+1):ncol(x), cols), drop=FALSE]
    x = x[, cols, drop=FALSE]
    # Why doesn't cbind accept NULL args like rbind?
    if (is.null(x.before) && is.null(x.after)) return(x)
    if (is.null(x.before) && !is.null(x.after)) return(cbind(x, x.after))
    if (!is.null(x.before) && is.null(x.after)) return(cbind(x.before, x))
    return(cbind(x.before, x, x.after))
    }

################################################################################
# Like moveColumns(), but for rows.  Move specified rows of matrix or data frame
# to specified new position.
#
# Arguments:
#   x: the data frame or matrix.
#   rows: names or numbers of rows to move, in the order that they are
#       to appear after being moved.
#   afterRow: name or number of row to move the rows after.
#   beforeRow: name or number of row to move the rows before.
#       (If both afterRow and beforeRow are NULL, beforeRow is taken as the
#       lowest-numbered row of the rows specified by 'rows', which is
#       useful if a subset of rows are being sorted, since 'rows' in that
#       case can be row names sorted using order().
#
# Returns: modified data frame or matrix.
#
# Example of sorting the df row numbers in "sr" by the values in column "sc":
#   df = data.frame(a=100:110, b=0:10, c=10:0, d=15:5, e=900:910)
#   df
#   sc = "d"
#   sr = 5:8
#   df = moveRows(df, sr[order(df[sr, sc])])
#   df
################################################################################
moveRows = function(x, rows, afterRow=NULL, beforeRow=NULL)
    {
    # Check rows argument.
    if (!is.numeric(rows))
        {
        missingRows = rows[!rows %in% rownames(x)]
        if (length(missingRows) > 0)
            stop("moveRows: No such rows: ", paste(missingRows, collapse=" "))
        rows = match(rows, rownames(x))
        }

    # Check afterRow and beforeRow arguments.
    if (is.null(afterRow) && is.null(beforeRow))
        beforeRow = min(rows)
    if (!is.null(afterRow) && !is.null(beforeRow))
        stop("moveRows: Neither afterRow nor beforeRow is NULL")
    before = FALSE
    row = afterRow
    if (!is.null(beforeRow))
        {
        before = TRUE
        row = beforeRow
        }
    if (length(row) != 1)
        stop("moveRows: expected exactly one row for afterRow/beforeRow, got: ", length(row))
    if (!is.numeric(row))
        {
        if (!any(rownames(x) == row))
            stop("moveRows: No such row: ", row)
        row = which(rownames(x) == row)[1]
        }
    if (before)
        row = row-1 # Move AFTER row 'row'

    # Now do the work.
    x.before = NULL
    if (row > 0)
        x.before = x[setdiff(1:row, rows),, drop=FALSE]
    x.after = NULL
    if (row < nrow(x))
        x.after = x[setdiff((row+1):nrow(x), rows),, drop=FALSE]
    x = x[rows,, drop=FALSE]
    return(rbind(x.before, x, x.after))
    }

################################################################################
# Remove columns specified by vector cols from matrix or data frame mdf and return result.
################################################################################
removeColumns = function(mdf, cols)
    {
    # Do this in a way that allows cols to be numbers or column names.
    nCol = ncol(mdf)
    deleteCol = rep(FALSE, nCol)
    names(deleteCol) = colnames(mdf)
    deleteCol[cols] = TRUE
    for (i in seq(nCol,1))
        if (deleteCol[i])
            mdf = mdf[,-i, drop=FALSE]
    return(mdf)
    }

################################################################################
# Remove rows specified by vector rows from matrix or data frame mdf and return result.
################################################################################
removeRows = function(mdf, rows)
    {
    # Do this in a way that allows rows to be numbers or row names.
    nRow = nrow(mdf)
    deleteRow = rep(FALSE, nRow)
    names(deleteRow) = rownames(mdf)
    deleteRow[rows] = TRUE
    for (i in seq(nRow,1))
        if (deleteRow[i])
            mdf = mdf[-i, , drop=FALSE]
    return(mdf)
    }

################################################################################
# Find the union of intervals in dfIntervals1 and dfIntervals2, each of which
# has one row per start..end interval, optionally with each interval associated
# with a 'group' (e.g. chromosome).  The interval start and end positions must
# be integer values, not numeric, and are rounded here to ensure that.
#
# Arguments:
#   dfIntervals1: data frame containing intervals defined by columns whose names
#       are given by group1, start1, end1.  No two intervals with the same value
#       in column 'group1' may overlap, else an error occurs.  They MAY abut one
#       another (end of one interval is one less than start of following one).
#       Merge overlapping intervals before calling this or see unionIntervals2().
#   dfIntervals2: data frame containing intervals defined by columns whose names
#       are given by group2, start2, end2.  No two intervals with the same value
#       in column 'group2' may overlap, else an error occurs.  They MAY abut one
#       another.  Merge overlapping intervals before calling this or see
#       unionIntervals2().
#   group1: name of dfIntervals1 column that determines how to group dfIntervals1
#       rows.  Rows are grouped by values in this column, and that value is then
#       used to find the corresponding group of dfIntervals2 using its column
#       given by group2.  If NULL, ALL rows of dfIntervals1 and dfIntervals2 are
#       grouped together, and group2 must also be NULL.
#   start1: name of dfIntervals1 column containing numeric values that give the
#       1-based START positions of the intervals.
#   end1: name of dfIntervals1 column like 'start1' but for the 1-based END
#       positions of the intervals.
#   group2: like 'group1' but for dfIntervals2 grouping column.
#   start2: like 'start1' but for dfIntervals2 START position column.
#   end2: like 'end1' but for dfIntervals2 END position column.
#
# Returns: a data frame containing the union of all intervals of dfIntervals1
#   and dfIntervals2.  Column names are those given by arguments group1, start1,
#   and end1, plus columns "row1" and "row2".  Every interval in either
#   dfIntervals1 or dfIntervals2 can be found as one or more abutting intervals
#   (start of next interval is equal to end of previous interval + 1) in this
#   data frame.  Column "row1" contains the row number in dfIntervals1 that
#   contains the interval, or is 0 if none do.  Column "row2" likewise contains
#   the row number in dfIntervals2 that contains the interval, or is 0 if none
#   do.  E.g. if dfIntervals1 has interval (1,10) and dfIntervals2 has interval
#   (10,20), then this data frame will have the intervals (1,9), (10,10), and
#   (11,20), with row1 being 1,1,0 and row2 being 0,1,1.  The data frame is
#   sorted by the group1, start1, and end1 columns.
#
# Test:
#   dfI1 = data.frame(start=c(1, 20, 35, 40, 60, 80, 105, 120, 145, 153, 159, 170, 220, 250, 270, 275, 280, 290, 301, 304, 400, 3000),
#                       end=c(5, 25, 35, 50, 65, 90, 110, 130, 151, 157, 165, 200, 230, 260, 270, 275, 280, 295, 301, 304, 500, 4000))
#   dfI2 = data.frame(start=c(10, 30, 40, 60, 85, 100, 115, 122, 126, 130, 150, 180, 210, 250, 255, 260, 270, 291, 294, 300, 1000, 3000),
#                       end=c(15, 30, 45, 70, 90, 110, 120, 124, 128, 135, 160, 190, 240, 250, 255, 260, 280, 291, 294, 305, 2000, 4000))
#   dfU = unionIntervals(dfI1, dfI2, group1=NULL, group2=NULL)
#   dfU # Tediously checked, is correct.  Have I missed any important test cases?
################################################################################
unionIntervals = function(dfIntervals1, dfIntervals2,
    group1="chr", start1="start", end1="end", group2=group1, start2=start1, end2=end1)
    {
    cols = c(group1, start1, end1)
    missing = !cols %in% colnames(dfIntervals1)
    if (any(missing))
        stop("dfIntervals1 missing columns: ", paste(cols[missing], collapse=","))

    cols = c(group2, start2, end2)
    missing = !cols %in% colnames(dfIntervals2)
    if (any(missing))
        stop("dfIntervals2 missing columns: ", paste(cols[missing], collapse=","))

    # Round the start and end positions.
    dfIntervals1[[start1]] = round(dfIntervals1[[start1]])
    dfIntervals1[[end1]] = round(dfIntervals1[[end1]])
    dfIntervals2[[start2]] = round(dfIntervals2[[start2]])
    dfIntervals2[[end2]] = round(dfIntervals2[[end2]])

    # Add a column to dfIntervals1 containing its row number.  We need this
    # because we will sort this data frame, but we want to know the original row
    # number of this BEFORE sorting.
    dfIntervals1$row = 1:nrow(dfIntervals1)

    # Likewise for dfIntervals2.
    dfIntervals2$row = 1:nrow(dfIntervals2)

    # Make sure both data frames are sorted.  If "group" is NULL, set "groupVals"
    # to a single value so we loop once below, else set it to the unique values
    # in the two group columns.
    if (is.null(group2) != is.null(group1))
        stop("'group1' and 'group2' must both be NULL or non-NULL")
    if (is.null(group1))
        {
        dfIntervals1 = dfIntervals1[order(dfIntervals1[[start1]], dfIntervals1[[end1]]),]
        dfIntervals2 = dfIntervals2[order(dfIntervals2[[start2]], dfIntervals2[[end2]]),]
        groupVals = 1
        }
    else
        {
        dfIntervals1 = dfIntervals1[order(dfIntervals1[[group1]], dfIntervals1[[start1]], dfIntervals1[[end1]]),]
        dfIntervals2 = dfIntervals2[order(dfIntervals2[[group2]], dfIntervals2[[start2]], dfIntervals2[[end2]]),]
        groupVals = union(dfIntervals1[[group1]], dfIntervals2[[group2]])
        }

    # Create empty dfUnion result data frame.
    dfUnion = NULL

    # Do union separately for each groupVals value.
    for (groupVal in groupVals)
        {
        # Get indicators ind.df1 and ind.df2 of the data for this groupVal.
        if (is.null(group1))
            {
            ind.df1 = rep(TRUE, nrow(dfIntervals1))
            ind.df2 = rep(TRUE, nrow(dfIntervals2))
            }
        else
            {
            ind.df1 = (dfIntervals1[[group1]] == groupVal)
            ind.df2 = (dfIntervals2[[group2]] == groupVal)
            }

        # Make sure dfIntervals1[ind.df1, end1] always >= dfIntervals1[ind.df1, start1].
        ind = (dfIntervals1[ind.df1, end1] < dfIntervals1[ind.df1, start1])
        if (any(ind))
            stop(sum(ind),
                " negative length entries in dfIntervals1 for group value ",
                groupVal, " rows ", paste(dfIntervals1$row[ind.df1][ind], collapse=","))

        # Make sure dfIntervals2[ind.df2, end2] always >= dfIntervals2[ind.df2, start2].
        ind = (dfIntervals2[ind.df2, end2] < dfIntervals2[ind.df2, start2])
        if (any(ind))
            stop(sum(ind),
                " negative length entries in dfIntervals2 for group value ",
                groupVal, " rows ", paste(dfIntervals2$row[ind.df2][ind], collapse=","))

        # Make sure dfIntervals1[ind.df1,] does not contain any overlaps.
        N.df1 = sum(ind.df1)
        if (N.df1 > 1)
            {
            ind = (dfIntervals1[ind.df1, end1][-N.df1]+1 > dfIntervals1[ind.df1, start1][-1])
            if (any(ind))
                stop(sum(ind),
                    " overlapping entries in dfIntervals1 for chr ", groupVal,
                    " rows ", paste(dfIntervals1$row[ind.df1][c(ind, FALSE)], collapse=","),
                    " and following rows")
            }

        # Make sure dfIntervals2[ind.df2,] does not contain any overlaps.
        N.df2 = sum(ind.df2)
        if (N.df2 > 1)
            {
            ind = (dfIntervals2[ind.df2, end2][-N.df2]+1 > dfIntervals2[ind.df2, start2][-1])
            if (any(ind))
                stop(sum(ind),
                    " overlapping entries in dfIntervals2 for chr ", groupVal,
                    " rows ", paste(dfIntervals2$row[ind.df2][c(ind, FALSE)], collapse=","),
                    " and following rows")
            }

        # Create a vector of the start positions that are present in the union
        # of the intervals.  The interval starts are the unique values in the
        # union:
        #   (dfIntervals1[[start1]], dfIntervals2[[start2]], e1+1, e2+1)
        # where:
        #   e1 = each dfIntervals1[[end1]] where e1 >= dfIntervals2[i, start2] && e1 < dfIntervals2[i, end2] for some i
        #   e2 = each dfIntervals2[[end2]] where e2 >= dfIntervals1[j, start1] && e2 < dfIntervals1[j, end1] for some j
        # (when a segment ENDS (e) WITHIN a segment of the opposite dfIntervals,
        # then a new segment STARTS at the following position, e+1).
        #
        # Likewise, create a vector of the end positions that are present in the
        # union of the intervals.  The interval ends are the unique values in
        # the union: (dfIntervals1[[end1]], dfIntervals2[[end1]], s1-1, s2-1)
        # where:
        #   s1 = each dfIntervals1[[start1]] where s1 > dfIntervals2[i, start2] && s1 <= dfIntervals2[i, end2] for some i
        #   s2 = each dfIntervals2[[start2]] where s2 > dfIntervals1[j, start1] && s2 <= dfIntervals1[j, end1] for some j
        # (when a segment STARTS (s) WITHIN a segment of the opposite dfIntervals,
        # then a new segment ENDS at the preceding position, s-1).

        starts = c(dfIntervals1[ind.df1, start1], dfIntervals2[ind.df2, start2])
        ends = c(dfIntervals1[ind.df1, end1], dfIntervals2[ind.df2, end2])

        #
        # We will use findInterval() to find the e1/e2/s1/s2 values above, and
        # we'll make findInterval's vector of non-decreasing positions be an
        # interleaving of "start" and "end" entries, since those have been
        # sorted to be non-decreasing, and end >= start, and the following start
        # > this end.
        #
        # Here is the findInterval(x, V) description:
        # Given a vector of non-decreasing breakpoints in V, find the interval
        # containing each element of x; i.e., if i = findInterval(x, V), for
        # each index j in x: V[i[j]] ≤ x[j] < V[i[j] + 1], where V[0] = -Inf,
        # V[N+1] = +Inf, and N = length(V).  That condition suffices for the
        # e1= and e2= conditions above.  For the s1= and s2= conditions, we want
        # to swap ≤ and <, and left.open=TRUE does just that.
        #
        # If we give findInterval a V argument that is an interleaved
        # combination of dfIntervals2[[start2]] and dfIntervals2[[end2]] values,
        # the interleaved combinations will alternate between intervals present
        # WITHIN dfIntervals2 and intervals BETWEEN its rows, and findInterval
        # will give an index for the location of each x argument that will
        # indicate whether that x value is WITHIN or BETWEEN a dfIntervals2 row.
        # Odd return values mean the position is between a start..end interval
        # in dfIntervals2, while even return values mean the position is outside
        # all start..end intervals.
        #
        # We need to consider what happens when the condition start==end exists
        # (interval is a single point).  In that case, we want to reject any e1,
        # e2, s1, or s2 that is equal to start and end, i.e. we want the
        # condition to fail always.  The behavior of findInterval in those cases
        # is always to return an even index number into our interleaved
        # positions vector, and an even number means the x value is outside all
        # intervals, which is what we want.
        #
        # We need to handle the two ends (start and end of chromosome) correctly,
        # which is accomplished by recognizing that a return value of 0 from
        # findInterval means the position is to the left of the first start in
        # dfIntervals2, and a value of N = 2*(number rows) means the position
        # is to the right of the last end in dfIntervals2.
        #
        # We do the same thing swapping the roles of dfIntervals1 and dfIntervals2.

        interleavedPositions1 = as.vector(
            matrix(c(dfIntervals1[ind.df1, start1], dfIntervals1[ind.df1, end1]), nrow=2, byrow=TRUE))
        interleavedPositions2 = as.vector(
            matrix(c(dfIntervals2[ind.df2, start2], dfIntervals2[ind.df2, end2]), nrow=2, byrow=TRUE))

        ii.start1 = findInterval(dfIntervals1[ind.df1, start1], interleavedPositions2, left.open=TRUE)
        ii.end1 = findInterval(dfIntervals1[ind.df1, end1], interleavedPositions2)
        ii.start2 = findInterval(dfIntervals2[ind.df2, start2], interleavedPositions1, left.open=TRUE)
        ii.end2 = findInterval(dfIntervals2[ind.df2, end2], interleavedPositions1)

        # Are starts and ends within the segment of the opposite set of intervals?
        # See e1, e2, s1, s2 above for the conditions these are testing.
        indWithin.start1 = (ii.start1 %% 2 != 0)
        indWithin.end1 = (ii.end1 %% 2 != 0)
        indWithin.start2 = (ii.start2 %% 2 != 0)
        indWithin.end2 = (ii.end2 %% 2 != 0)

        # Union of all starting and ending points.
        starts = c(starts, dfIntervals1[ind.df1, end1][indWithin.end1]+1, dfIntervals2[ind.df2, end2][indWithin.end2]+1)
        ends = c(ends, dfIntervals1[ind.df1, start1][indWithin.start1]-1, dfIntervals2[ind.df2, start2][indWithin.start2]-1)

        starts = sort(unique(starts))
        ends = sort(unique(ends))

        if (length(starts) != length(ends))
            stop("Software error: expected same number of segment starting and ending positions, groupVal:", groupVal,
                " length(starts): ", length(starts), " length(ends): ", length(ends))
        if (any(ends < starts))
            stop("Software error: expected segment starts <= segment ends.")

        # Put start and end positions in a data frame.
        dfU = data.frame(starts=starts, ends=ends, row1=0, row2=0, stringsAsFactors=FALSE)
        if (!is.null(group1))
            dfU = data.frame(group=groupVal, dfU, stringsAsFactors=FALSE)

        # Use findInterval() again to find values for columns "row1" and "row2".
        # However, this time we want to know if the starting (or ending)
        # position of each dfU interval lies within any of the segments in
        # dfIntervals1 or dfIntervals2.  So, the case where start==end in the
        # latter data frames throws us off, because both of these conditions are
        # TRUE:
        #       V[i-1] ≤ x[j] ≤ V[i]
        #       V[i]   ≤ x[j] ≤ V[i+1]
        # To get around this, recompute the interleaved positions, using start-0.5
        # and end+0.5 as the starting and ending positions.
        interleavedPositions1 = as.vector(
            matrix(c(dfIntervals1[ind.df1, start1]-0.5, dfIntervals1[ind.df1, end1]+0.5), nrow=2, byrow=TRUE))
        interleavedPositions2 = as.vector(
            matrix(c(dfIntervals2[ind.df2, start2]-0.5, dfIntervals2[ind.df2, end2]+0.5), nrow=2, byrow=TRUE))
        ii.row1 = findInterval(starts, interleavedPositions1, left.open=TRUE)
        ii.row2 = findInterval(starts, interleavedPositions2, left.open=TRUE)
        ind.row1 = (ii.row1 %% 2 != 0)
        ind.row2 = (ii.row2 %% 2 != 0)
        idx.row1 = 1+ii.row1[ind.row1] %/% 2
        idx.row2 = 1+ii.row2[ind.row2] %/% 2
        dfU$row1[ind.row1] = dfIntervals1$row[ind.df1][idx.row1]
        dfU$row2[ind.row2] = dfIntervals2$row[ind.df2][idx.row2]

        # Append to dfUnion.
        dfUnion = rbind(dfUnion, dfU)
        }

    newColNames = colnames(dfUnion)
    newColNames[newColNames == "group"] = group1
    newColNames[newColNames == "starts"] = start1
    newColNames[newColNames == "ends"] = end1
    colnames(dfUnion) = newColNames
    return(dfUnion)
    }

################################################################################
# Like unionIntervals(), except that the intervals are allowed to abut by one
# position value, i.e. the end position of one interval may equal the start
# position of the next interval.  The interval start and end positions must
# be integer values, not numeric, and are rounded here to ensure that.  No
# interval can have an end position equal to its start position.
#
# Arguments:
#   dfIntervals1: data frame containing intervals defined by columns whose names
#       are given by group1, start1, end1.  No two intervals with the same value
#       in column 'group1' may overlap, else an error occurs.  They MAY abut one
#       another (end of one interval is EQUAL TO start of following one).
#   dfIntervals2: data frame containing intervals defined by columns whose names
#       are given by group2, start2, end2.  No two intervals with the same value
#       in column 'group2' may overlap, else an error occurs.  They MAY abut one
#       another.
#   group1: name of dfIntervals1 column that determines how to group dfIntervals1
#       rows.  Rows are grouped by values in this column, and that value is then
#       used to find the corresponding group of dfIntervals2 using its column
#       given by group2.  If NULL, ALL rows of dfIntervals1 and dfIntervals2 are
#       grouped together, and group2 must also be NULL.
#   start1: name of dfIntervals1 column containing numeric values that give the
#       1-based START positions of the intervals.
#   end1: name of dfIntervals1 column like 'start1' but for the 1-based END
#       positions of the intervals.
#   group2: like 'group1' but for dfIntervals2 grouping column.
#   start2: like 'start1' but for dfIntervals2 START position column.
#   end2: like 'end1' but for dfIntervals2 END position column.
#
# Returns: a data frame containing the union of all intervals of dfIntervals1
#   and dfIntervals2.  Column names are those given by arguments group1, start1,
#   and end1, plus columns "row1" and "row2".  Every interval in either
#   dfIntervals1 or dfIntervals2 can be found as one or more abutting intervals
#   (start of next interval is equal to end of previous interval) in this data
#   frame.  Column "row1" contains the row number in dfIntervals1 that contains
#   the interval, or is 0 if none do.  Column "row2" likewise contains the row
#   number in dfIntervals2 that contains the interval, or is 0 if none do.  E.g.
#   if dfIntervals1 has interval (1,10) and dfIntervals2 has interval
#   (5,20), then this data frame will have the intervals (1,5), (5,10), and
#   (10,20), with row1 being 1,1,0 and row2 being 0,1,1.  The data frame is
#   sorted by the group1, start1, and end1 columns.
#
# Test:
#   dfI1 = data.frame(start=c(1, 20, 40, 60, 80, 105, 3000),
#                       end=c(5, 25, 50, 65, 90, 110, 4000))
#   dfI2 = data.frame(start=c(10, 40, 60, 85, 100, 115, 3000),
#                       end=c(15, 45, 70, 90, 110, 120, 4000))
#   dfU = unionIntervals2(dfI1, dfI2, group1=NULL, group2=NULL)
#   dfU # Tediously checked, is correct.  Have I missed any important test cases?
################################################################################
unionIntervals2 = function(dfIntervals1, dfIntervals2,
    group1="chr", start1="start", end1="end", group2=group1, start2=start1, end2=end1)
    {
    cols = c(group1, start1, end1)
    missing = !cols %in% colnames(dfIntervals1)
    if (any(missing))
        stop("dfIntervals1 missing columns: ", paste(cols[missing], collapse=","))

    cols = c(group2, start2, end2)
    missing = !cols %in% colnames(dfIntervals2)
    if (any(missing))
        stop("dfIntervals2 missing columns: ", paste(cols[missing], collapse=","))

    # Round the start and end positions.
    dfIntervals1[[start1]] = round(dfIntervals1[[start1]])
    dfIntervals1[[end1]] = round(dfIntervals1[[end1]])
    dfIntervals2[[start2]] = round(dfIntervals2[[start2]])
    dfIntervals2[[end2]] = round(dfIntervals2[[end2]])

    # Add a column to dfIntervals1 containing its row number.  We need this
    # because we will sort this data frame, but we want to know the original row
    # number of this BEFORE sorting.
    dfIntervals1$row = 1:nrow(dfIntervals1)

    # Likewise for dfIntervals2.
    dfIntervals2$row = 1:nrow(dfIntervals2)

    # Make sure both data frames are sorted.  If "group" is NULL, set "groupVals"
    # to a single value so we loop once below, else set it to the unique values
    # in the two group columns.
    if (is.null(group2) != is.null(group1))
        stop("'group1' and 'group2' must both be NULL or non-NULL")
    if (is.null(group1))
        {
        dfIntervals1 = dfIntervals1[order(dfIntervals1[[start1]], dfIntervals1[[end1]]),]
        dfIntervals2 = dfIntervals2[order(dfIntervals2[[start2]], dfIntervals2[[end2]]),]
        groupVals = 1
        }
    else
        {
        dfIntervals1 = dfIntervals1[order(dfIntervals1[[group1]], dfIntervals1[[start1]], dfIntervals1[[end1]]),]
        dfIntervals2 = dfIntervals2[order(dfIntervals2[[group2]], dfIntervals2[[start2]], dfIntervals2[[end2]]),]
        groupVals = union(dfIntervals1[[group1]], dfIntervals2[[group2]])
        }

    # Create empty dfUnion result data frame.
    dfUnion = NULL

    # Do union separately for each groupVals value.
    for (groupVal in groupVals)
        {
        # Get indicators ind.df1 and ind.df2 of the data for this groupVal.
        if (is.null(group1))
            {
            ind.df1 = rep(TRUE, nrow(dfIntervals1))
            ind.df2 = rep(TRUE, nrow(dfIntervals2))
            }
        else
            {
            ind.df1 = (dfIntervals1[[group1]] == groupVal)
            ind.df2 = (dfIntervals2[[group2]] == groupVal)
            }

        # Make sure dfIntervals1[ind.df1, end1] always > dfIntervals1[ind.df1, start1].
        ind = (dfIntervals1[ind.df1, end1] <= dfIntervals1[ind.df1, start1])
        if (any(ind))
            stop(sum(ind),
                " negative- or zero-length entries in dfIntervals1 for group value ",
                groupVal, " rows ", paste(dfIntervals1$row[ind.df1][ind], collapse=","))

        # Make sure dfIntervals2[ind.df2, end2] always > dfIntervals2[ind.df2, start2].
        ind = (dfIntervals2[ind.df2, end2] <= dfIntervals2[ind.df2, start2])
        if (any(ind))
            stop(sum(ind),
                " negative- or zero-length entries in dfIntervals2 for group value ",
                groupVal, " rows ", paste(dfIntervals2$row[ind.df2][ind], collapse=","))

        # Make sure dfIntervals1[ind.df1,] does not contain any overlaps, but allow
        # the intervals to abut (have the same start/end position).
        N.df1 = sum(ind.df1)
        if (N.df1 > 1)
            {
            ind = (dfIntervals1[ind.df1, end1][-N.df1] > dfIntervals1[ind.df1, start1][-1])
            if (any(ind))
                stop(sum(ind),
                    " overlapping entries in dfIntervals1 for chr ", groupVal,
                    " rows ", paste(dfIntervals1$row[ind.df1][c(ind, FALSE)], collapse=","),
                    " and following rows")
            }

        # Make sure dfIntervals2[ind.df2,] does not contain any overlaps, may abut.
        N.df2 = sum(ind.df2)
        if (N.df2 > 1)
            {
            ind = (dfIntervals2[ind.df2, end2][-N.df2] > dfIntervals2[ind.df2, start2][-1])
            if (any(ind))
                stop(sum(ind),
                    " overlapping entries in dfIntervals2 for chr ", groupVal,
                    " rows ", paste(dfIntervals2$row[ind.df2][c(ind, FALSE)], collapse=","),
                    " and following rows")
            }

        # This is much easier than in unionIntervals().  We simply need to make
        # vector containing all unique start/end positions, sort it, and then
        # use match() to find which ones are used in each dfIntervals1 and
        # dfIntervals2 segment start and end position.  For a given segment, if
        # match() finds position #17 as the start position and position #22 as
        # the end position, then the result data frame will have 5 segments
        # whose start and end positions are given by positions #17 through #22.

        positions = sort(unique(c(
            dfIntervals1[ind.df1, start1], dfIntervals2[ind.df2, start2],
            dfIntervals1[ind.df1, end1], dfIntervals2[ind.df2, end2])))

        ii.start1 = match(dfIntervals1[ind.df1, start1], positions)
        ii.end1 = match(dfIntervals1[ind.df1, end1], positions)
        num.segs1 = ii.end1 - ii.start1

        ii.start2 = match(dfIntervals2[ind.df2, start2], positions)
        ii.end2 = match(dfIntervals2[ind.df2, end2], positions)
        num.segs2 = ii.end2 - ii.start2

        # Get vectors of indexes into positions[] of the starting positions of
        # each segment in the result data frame.  The indexes of the ending
        # positions are just one more than this.
        idx.start1 = unlist(sapply(1:N.df1, function(i) ii.start1[i]:(ii.end1[i]-1), simplify=FALSE))
        idx.start2 = unlist(sapply(1:N.df2, function(i) ii.start2[i]:(ii.end2[i]-1), simplify=FALSE))

        # Get the indexes in dfIntervals1 and dfIntervals2 for each result segment.
        ii.row1 = unlist(sapply(1:N.df1, function(i) rep(i, num.segs1[i]), simplify=FALSE))
        ii.row2 = unlist(sapply(1:N.df2, function(i) rep(i, num.segs2[i]), simplify=FALSE))

        # Make separate result data frames for dfIntervals1 and dfIntervals2.
        dfU1 = data.frame(starts=positions[idx.start1], ends=positions[idx.start1+1],
            row1=dfIntervals1$row[ind.df1][ii.row1], row2=0, stringsAsFactors=FALSE)
        dfU2 = data.frame(starts=positions[idx.start2], ends=positions[idx.start2+1],
            row1=0, row2=dfIntervals2$row[ind.df2][ii.row2], stringsAsFactors=FALSE)

        # Merge the data frames.  If the start positions match, then the end
        # positions also match (because every end position is the one that
        # follows immediately after the start position), and the rows are merged.
        # Each data frame has unique values in its start positions, never any
        # duplicates.
        idx2.merge = match(idx.start1, idx.start2)
        ind1.merge = !is.na(idx2.merge)
        dfU = dfU1
        if (any(ind1.merge))
            dfU$row2[ind1.merge] = dfU2$row2[idx2.merge[ind1.merge]]
        ind2.merge = ! dfU2$starts %in% dfU$starts
        if (any(ind2.merge))
            {
            dfU = rbind(dfU, dfU2[ind2.merge,])
            dfU = dfU[order(dfU$starts),]
            }

        # Add a group column if needed and append to dfUnion.
        if (!is.null(group1))
            dfU = data.frame(group=groupVal, dfU, stringsAsFactors=FALSE)
        dfUnion = rbind(dfUnion, dfU)
        }

    newColNames = colnames(dfUnion)
    newColNames[newColNames == "group"] = group1
    newColNames[newColNames == "starts"] = start1
    newColNames[newColNames == "ends"] = end1
    colnames(dfUnion) = newColNames
    return(dfUnion)
    }

################################################################################
# Find the rows of dfIntervals whose start..end intervals intersect start..end
# intervals of one or more of dfContainer's rows, conditional on intersecting
# rows having the same value in the 'group' columns.  Optionally, require that
# a single dfContainer row's interval fully contain each intersecting interval
# from dfIntervals.
#
# Arguments:
#   dfIntervals: data frame containing intervals defined by columns whose names
#       are given by groupI, startI, endI.
#   dfContainer: data frame containing intervals defined by columns whose names
#       are given by groupC, startC, endC.  No two intervals with the same value
#       in column 'groupC' may overlap, else an error occurs.  They MAY abut one
#       another (end of one interval is one less than start of following one).
#       Merge overlapping intervals before calling this.
#   groupI: name of dfIntervals column that determines how to group dfIntervals
#       rows for intersection.  Rows are grouped by values in this column, and
#       that value is then used to find the corresponding group of dfContainer
#       using its column given by groupC.  If NULL, ALL rows of dfIntervals are
#       intersected together, and groupC must also be NULL.
#   startI: name of dfIntervals column containing numeric values that give the
#       1-based START positions of the intervals.
#   endI: name of dfIntervals column like 'startI' but for the 1-based END
#       positions of the intervals.
#   groupC: like 'groupI' but for dfContainer grouping column.
#   startC: like 'startI' but for dfContainer START position column.
#   endC: like 'endI' but for dfContainer END position column.
#   requireFullyContained: if TRUE, intersections are only counted as an
#       intersection if the dfIntervals interval is FULLY CONTAINED within ONE
#       dfContainer interval.  Otherwise, any overlap at all counts as an
#       intersection.
#
# Note regarding "complete group" entries:
#   A value of 0 in both the startC and endC column of dfContainer indicates
#   that any dfIntervals interval whose groupI value matches the groupC value is
#   considered a contained interval.  In that case there can be no other
#   dfContainer rows with the same groupC value.
#
# Returns: value depends on requireFullyContained:
#   requireFullyContained = TRUE:
#       Returns a numeric vector of length nrow(dfIntervals), 0 if the
#           corresponding dfIntervals interval is NOT fully contained within a
#           dfContainer interval, else the INDEX of the row within dfContainer
#           whose interval contains the dfIntervals row interval.
#   requireFullyContained = FALSE:
#       Returns a list with these elements:
#           rowI: numeric vector of length nrow(dfIntervals) containing the
#               row numbers in dfIntervals that overlap zero or more rows
#               in dfContainer.  These are in the range 1..nrow(dfIntervals) but
#               not necessarily in that order.
#           rowC: list of vectors, length of list is nrow(dfIntervals), and each
#               vector contains the row numbers of all dfContainer rows that
#               overlap the dfIntervals row with the corresponding index in
#               rowI, or an empty vector if none overlap.  For example, if
#               rowI[7] is 28 and rowC[[7]] is c(98, 1545), this means that
#               dfIntervals row 28 intersects dfContainer rows 98 and 1545.
################################################################################
intersectIntervals = function(dfIntervals, dfContainer,
    groupI="chr", startI="start", endI="end", groupC=groupI, startC=startI, endC=endI,
    requireFullyContained=TRUE)
    {
    cols = c(groupI, startI, endI)
    missing = !cols %in% colnames(dfIntervals)
    if (any(missing))
        stop("dfIntervals missing columns: ", paste(cols[missing], collapse=","))

    cols = c(groupC, startC, endC)
    missing = !cols %in% colnames(dfContainer)
    if (any(missing))
        stop("dfContainer missing columns: ", paste(cols[missing], collapse=","))

    # Add a column to dfIntervals containing its row number.  We need this because we
    # will sort this data frame, but we want to know the original row number of this
    # BEFORE sorting.
    dfIntervals$row = 1:nrow(dfIntervals)

    # Add a column to dfContainer containing its row number.  We need this to be able
    # to know the original row in dfContainer that contains a row of dfIntervals.
    dfContainer$row = 1:nrow(dfContainer)

    # Make a list of vectors, one vector per dfIntervals row, that will contain
    # the intersecting row numbers in dfContainer.
    rowC = sapply(1:nrow(dfIntervals), function(V) return(integer(0)), simplify=FALSE)

    # Add a column to dfIntervals that will contain the dfContainer$row value of
    # the FIRST intersecting row, or 0 if none.
    dfIntervals$first = 0

    # Make sure both data frames are sorted, and get group values in common
    # between dfIntervals and dfContainer.  If "group" is NULL, set "groupVals"
    # to a single value so we loop once below.
    if (is.null(groupC) != is.null(groupI))
        stop("'groupI' and 'groupC' must both be NULL or non-NULL")
    if (is.null(groupI))
        {
        dfIntervals = dfIntervals[order(dfIntervals[[startI]], dfIntervals[[endI]]),]
        dfContainer = dfContainer[order(dfContainer[[startC]], dfContainer[[endC]]),]
        groupVals = 1
        }
    else
        {
        dfIntervals = dfIntervals[order(dfIntervals[[groupI]], dfIntervals[[startI]], dfIntervals[[endI]]),]
        dfContainer = dfContainer[order(dfContainer[[groupC]], dfContainer[[startC]], dfContainer[[endC]]),]
        groupVals = intersect(dfIntervals[[groupI]], dfContainer[[groupC]])
        if (length(groupVals) == 0)
            stop("no 'groupI' and 'groupC' column values are in common")
        }

    # Do intersection separately for each groupVals value.  Put intersecting row
    # numbers in rowC list.
    for (groupVal in groupVals)
        {
        # Get indicators ind.dfI and ind.dfC of the data for this groupVal.
        if (is.null(groupI))
            {
            ind.dfI = rep(TRUE, nrow(dfIntervals))
            ind.dfC = rep(TRUE, nrow(dfContainer))
            }
        else
            {
            ind.dfI = (dfIntervals[[groupI]] == groupVal)
            ind.dfC = (dfContainer[[groupC]] == groupVal)
            }

        # If either indicator is empty, skip this group.
        if (!any(ind.dfI) || !any(ind.dfC))
            next

        # Make sure dfIntervals[ind.dfI, endI] always >= dfIntervals[ind.dfI, startI].
        ind = (dfIntervals[ind.dfI, endI] < dfIntervals[ind.dfI, startI])
        if (any(ind))
            stop(sum(ind),
                " negative length entries in dfIntervals for group value ",
                groupVal, " rows ", paste(dfIntervals$row[ind.dfI][ind], collapse=","))

        # Make sure dfContainer[ind.dfC, endC] always >= dfContainer[ind.dfC, startC].
        ind = (dfContainer[ind.dfC, endC] < dfContainer[ind.dfC, startC])
        if (any(ind))
            stop(sum(ind),
                " negative length entries in dfContainer for group value ",
                groupVal, " rows ", paste(dfContainer$row[ind.dfC][ind], collapse=","))

        # Make sure dfContainer[ind.dfC,] does not contain any overlaps.
        N.dfC = sum(ind.dfC)
        if (N.dfC > 1)
            {
            ind = (dfContainer[ind.dfC, endC][-N.dfC]+1 > dfContainer[ind.dfC, startC][-1])
            if (any(ind))
                stop(sum(ind),
                    " overlapping entries in dfContainer for chr ", groupVal,
                    " rows ", paste(dfContainer$row[ind.dfC][c(ind, FALSE)], collapse=","),
                    " and following rows")
            }

        # If there is a dfContainer entry for this group that has 0 for both its
        # startC and endC values, all dfIntervals intervals are contained by it.
        ind = (dfContainer[ind.dfC, startC] == 0 & dfContainer[ind.dfC, endC] == 0)
        if (any(ind))
            {
            rowNum = dfContainer$row[ind.dfC][ind][1]
            rowC[ind.dfI] = sapply(rowC[ind.dfI], function(V) return(rowNum), simplify=FALSE)
            dfIntervals$first[ind.dfI] = rowNum
            }
        else
            {
            # We will use findInterval() in much the same way as it was used
            # with unionIntervals(), and we'll make the vector of non-decreasing
            # positions be an interleaving of "start" and "end" entries, since
            # those have been sorted to be non-decreasing, and end >= start, and
            # the following start > this end.  We'll find the dfContainer
            # interval within which dfIntervals[[startI]] lies, and the one
            # within which dfIntervals[[endI]] lies.  If those two intervals are
            # not the same one, the dfIntervals row is contained within more
            # than one row of dfContainer.  We determine the intersecting
            # dfContainer intervals for each dfIntervals interval. We also need
            # to deal with the endpoints right at dfContainer[[startC]] and
            # dfContainer[[endC]] carefully.
            #
            # Here is the findInterval(x, V) description, modified for use with
            # the findInterval() argument rightmost.closed=TRUE:
            # Given a vector of non-decreasing breakpoints in V, find the interval
            # containing each element of x; i.e., if i = findInterval(x, V), for
            # each index j in x: V[i[j]] ≤ x[j] ≤ V[i[j] + 1], where V[0] = -Inf,
            # V[N+1] = +Inf, and N = length(V).
            #
            # Note that if x[j] == V[i], then index i-1 will be returned rather
            # than index i, because both of these conditions are TRUE:
            #       V[i-1] ≤ x[j] ≤ V[i]
            #       V[i]   ≤ x[j] ≤ V[i+1]
            # We still wouldn't get the correct result if we used rightmost.closed=FALSE,
            # because in that case index i+1 would be returned rather than index i.  We
            # could fix that by incrementing the ending position of each interval, but
            # in that case we would have to disallow abutting intervals.  If we used
            # left.open=TRUE and rightmost.closed=FALSE, we would be looking at this
            # condition:
            #       V[i] < x[j] ≤ V[i+1]
            # and so in order to get the correct result when x[j] = V[i], we would
            # need to decrement the starting positions, again causing problems with
            # abutting intervals.  What we are looking for is to place interval
            # boundaries BETWEEN two bases, which we can do by decrementing the
            # start position by 0.5 and incrementing the end position by 0.5.  In
            # that case, the boundary conditions don't matter because they will
            # never occur.  So, that is what we will do.
            #
            # If we give findInterval a V argument that is an interleaved
            # combination of dfContainer[[startC]]-0.5 and
            # dfContainer[[endC]]+0.5 values, the interleaved combinations will
            # alternate between intervals present WITHIN dfContainer and
            # intervals BETWEEN its rows, and findInterval will give an index
            # for the location of each x argument that will indicate whether
            # that x value is WITHIN or BETWEEN a dfContainer row.  Odd return
            # values mean the position is between a start..end interval in
            # dfContainer, while even return values mean the position is outside
            # all start..end intervals.
            #
            # We need to handle the two ends (start and end of chromosome) correctly,
            # which is accomplished by recognizing that a return value of 0 from
            # findInterval means the position is to the left of the first start in
            # dfContainer, and a value of N = 2*(number rows) means the position
            # is to the right of the last end in dfContainer.
            #
            # We will call findInterval twice with the same interleaved values for V.
            # The first call will use x = dfIntervals[[startI]] and the second call
            # will use x = dfIntervals[[endI]].  The two indexes thus obtained for
            # each dfIntervals row will indicate for that row which rows it intersects
            # within dfContainer.  All dfContainer WITHIN intervals between those two
            # indexes intersect the dfIntervals row.

            interleavedPositions = as.vector(
                matrix(c(dfContainer[ind.dfC, startC]-0.5, dfContainer[ind.dfC, endC]+0.5), nrow=2, byrow=TRUE))

            # Call findInterval twice.
            ii.start = findInterval(dfIntervals[ind.dfI, startI], interleavedPositions)
            ii.end = findInterval(dfIntervals[ind.dfI, endI], interleavedPositions)

            # Determine which dfContainer row is the first row that intersects, and
            # which is the last.  Start by moving an EVEN index to the following (for
            # ii.start) or preceding (for ii.end) index, making the index odd and
            # thus making it indicate a particular dfContainer row.  Then, all rows
            # between the start and end row intersect.  If none intersect, we will
            # have kk.start > kk.end.  To support requireFullyContained, we require
            # that the returned indexes were identical.  For identical indexes in
            # a BETWEEN position, after adjustment of ii.start and ii.end there will
            # be no intersecting intervals.
            initiallyIdenticalIndexes = (ii.start == ii.end)
            ind = (ii.start %% 2 == 0)
            if (any(is.na(ind)))
                stop("Unexpected NAs")
            ii.start[ind] = ii.start[ind] + 1
            ind = (ii.end %% 2 == 0)
            if (any(is.na(ind)))
                stop("Unexpected NAs")
            ii.end[ind] = ii.end[ind] - 1
            kk.start = as.integer((ii.start+1)/2)
            kk.end = as.integer((ii.end+1)/2)
            anyIsect = (ii.start <= ii.end)
            if (requireFullyContained)
                anyIsect = anyIsect & initiallyIdenticalIndexes
            if (any(anyIsect))
                {
                # Optimization for speed.
                ind = (kk.start[anyIsect] == kk.end[anyIsect])
                if (any(ind))
                    {
                    rowNums = dfContainer$row[ind.dfC][kk.start[anyIsect][ind]]
                    rowC[ind.dfI][anyIsect][ind] = rowNums
                    dfIntervals$first[ind.dfI][anyIsect][ind] = rowNums
                    }
                if (any(!ind))
                    {
                    rowNums = dfContainer$row[ind.dfC]
                    rowC[ind.dfI][anyIsect][!ind] = sapply(which(anyIsect)[!ind], function(i)
                        return(rowNums[kk.start[i]]:rowNums[kk.end[i]]), simplify=FALSE)
                    dfIntervals$first[ind.dfI][anyIsect][!ind] = rowNums[kk.start[anyIsect][!ind]]
                    }
                }
            }
        }

    # If requireFullyContained, return dfIntervals$first, reordered into the
    # correct order using dfIntervals$row.
    if (requireFullyContained)
        {
        V = rep(0, nrow(dfIntervals))
        V[dfIntervals$row] = dfIntervals$first
        return(V)
        }

    # Otherwise, return the rowC, rowI list.
    return(list(rowI=dfIntervals$row, rowC=rowC))
    }

################################################################################
# Remove from dfIntervals any rows whose start..end is not contained fully within the
# start..end of one of dfContainer's rows, when both rows have the same value in
# the column whose name is given by the 'group' columns.
#
# Arguments:
#   dfIntervals: data frame with columns whose names are given by group, start, end.
#   dfContainer: another such data frame.  It must not contain any two rows with
#       the same 'group' column value that overlap or abut their start..end
#       segments.
#   groupI: name of dfIntervals column that determines how to group dfIntervals
#       rows for intersection.  Rows are grouped by values in this column, and
#       that value is then used to find the corresponding groups of dfContainer
#       using its column given by groupC.  If NULL, ALL rows of dfIntervals are
#       intersected together, and groupC must also be NULL.
#   startI: name of dfIntervals column containing numeric values that give the
#       1-based START positions of the intervals.
#   endI: name of dfIntervals column like 'startI' but for the 1-based END
#       positions of the intervals.
#   groupC: like 'groupI' but for dfContainer grouping column.
#   startC: like 'startI' but for dfContainer START position column.
#   endC: like 'endI' but for dfContainer END position column.
#   includeRowNum: if not NULL, this must be the name of a column to add to the
#       returned data frame (a subset of dfIntervals), containing the number of the row
#       within dfContainer that matched that row of dfIntervals.
#
# Returns: data frame of rows from dfIntervals whose 'groupI' column matches the
# 'groupC' column of a dfContainer row and that dfContainer row's start..end
# segment fully contains the dfIntervals row start..end segment.
################################################################################
removeNoncontainedIntervals = function(dfIntervals, dfContainer,
    groupI="chr", startI="start", endI="end", groupC=groupI, startC=startI, endC=endI,
    includeRowNum=NULL)
    {
    V = intersectIntervals(dfIntervals, dfContainer, groupI, startI, endI, groupC, startC, endC)
    ind = (V > 0)
    dfIntervals = dfIntervals[ind,]

    # If includeRowNum is not NULL, store the dfContainer row number in that
    # column of dfIntervals.
    if (!is.null(includeRowNum))
        dfIntervals[, includeRowNum] = V[ind]

    rownames(dfIntervals) = NULL
    return(dfIntervals)
    }

################################################################################
# Find the precise overlaps of intervals in dfIntervals with intervals in
# dfContainer, requiring that overlaps have the same value in the column whose
# name is given by the 'group' columns.
#
# Arguments:
#   dfIntervals: data frame with columns whose names are given by group, start, end.
#   dfContainer: another such data frame.  It must not contain any two rows with
#       the same 'group' column value that overlap or abut their start..end
#       segments.
#   groupI: name of dfIntervals column that determines how to group dfIntervals
#       rows for intersection.  Rows are grouped by values in this column, and
#       that value is then used to find the corresponding groups of dfContainer
#       using its column given by groupC.  If NULL, ALL rows of dfIntervals are
#       intersected together, and groupC must also be NULL.
#   startI: name of dfIntervals column containing numeric values that give the
#       1-based START positions of the intervals.
#   endI: name of dfIntervals column like 'startI' but for the 1-based END
#       positions of the intervals.
#   groupC: like 'groupI' but for dfContainer grouping column.
#   startC: like 'startI' but for dfContainer START position column.
#   endC: like 'endI' but for dfContainer END position column.
#
# Returns: data frame with one row for each interval that is part of both a
# dfIntervals interval and a dfContainer interval that has 'groupI' and 'groupC'
# columns matching.  Column names are "rowI", "rowC", "group" (if groupI and
# groupC are not NULL), "start", and "end", where "rowI" is the dfIntervals row
# containing the intersecting segment, and "rowC" is the dfContainer row
# containing it, "group" (if present) is the groupI/groupC value of the interval,
# and "start" and "end" are the 1-based start and end of the intersection.
################################################################################
getAllIntersectingIntervals = function(dfIntervals, dfContainer,
    groupI="chr", startI="start", endI="end", groupC=groupI, startC=startI, endC=endI)
    {
    L = intersectIntervals(dfIntervals, dfContainer,
        groupI, startI, endI, groupC, startC, endC, requireFullyContained=FALSE)

    # Get two equal-length vectors of indexes, one indexing dfIntervals and the
    # other dfContainer, each index-pair is for a pair of segments that intersect.
    # Then compute all the intersections.
    NI = sapply(L$rowC, length)
    rowI = sapply(1:nrow(dfIntervals), function(i) rep(L$rowI[i], NI[i]), simplify=FALSE)
    rowI = unlist(rowI)
    rowC = unlist(L$rowC)
    if (length(rowI) != length(rowC)) stop("Software error, expected rowI and rowC to have same lengths")
    dfIntersect = data.frame(rowI=rowI, rowC=rowC, stringsAsFactors=FALSE)
    if (!is.null(groupI))
        dfIntersect$group = dfIntervals[rowI, groupI]
    dfIntersect$start = pmax(dfIntervals[rowI, startI], dfContainer[rowC, startC])
    dfIntersect$end = pmin(dfIntervals[rowI, endI], dfContainer[rowC, endC])
    return(dfIntersect)
    }

################################################################################
# Apply arithmetic or set containment operations to columns of a data frame to
# select rows to be retained.
#
# Arguments:
#   df: data frame upon which selection is to operate.
#   keepList: a list of sublists of sub-sublists, see Details.
#   allowEmpty: TRUE to allow the possibility that the returned data frame has
#       no rows, FALSE to stop with error if this happens.
#
# Returns: data frame df with rows removed if they did not satisfy the conditions
# given by 'keepList'.
#
# Details: 'keepList' is a list.  Its elements are also lists, and each such
# sublist defines one or more conditions required to retain rows of df.  A row
# is retained only if the conditions in ALL of the sublists are met, i.e. the
# sublists are connected logically by "AND".
#
# Each sublist of 'keepList' has elements that are ALSO lists, and each such
# sub-sublist defines ONE condition required to retain rows of df.  A row is
# retained if AT LEAST ONE of the sub-sublist conditions is met, i.e. the
# sub-sublists are connected logically by "OR".
#
# Each sub-sublist contains the following elements (1 and 2 required, 3 depends):
#   Sub-sublist element 1: the name of a column in df
#   Sub-sublist element 2: one of these operators:
#     "NA"      means a row is retained if it has NA in that column
#     "="       means a row is retained if its column value is equal to element 3
#     "!="      means a row is retained if its column value is NOT equal to element 3
#     ">"       means a row is retained if its column value is > element 3
#     ">="      means a row is retained if its column value is >= element 3
#     "<"       means a row is retained if its column value is < element 3
#     "<="      means a row is retained if its column value is <= element 3
#     "in"      means a row is retained if its column value is contained in element 3
#     "not_in"  means a row is retained if its column value is NOT contained in element 3
#   Sub-sublist element 3: required unless element 2 is NO.  A single value for all
#       comparison operators in element 2, else a vector of one or more values
#       (possibly including NA) if element 2 is "in" or "not_in".
#
# For example, to express the conditions:
#
#  (column A is one of ("x", "y", or "z")) and (column B > 0.1) and (column B < 0.9)
#  and (column C = 20 or is NA) and (column D != "X" or column E not one of ("p", "q"))
#
# you would use:
#
#   keepList=list(
#       list(list("A", "in", c("x","y","z"))),
#       list(list("B", ">", 0.1)),
#       list(list("B", "<", 0.9)),
#       list(list("C", NA), list("C", "=", 20)),
#       list(list("D", "!=", "X"), list("E", "not_in", c("p", "q")))
#       )
# Each of the lines above is connected by "AND".  On each line, each list() except
# the first is connected by "OR".
#
# Notes: keepList may be an empty list, in which case df is returned unchanged.
################################################################################
filterDf = function(df, keepList, allowEmpty=FALSE)
    {
    err = function(...) stop("filterDf: ", ...)
    if (!is.data.frame(df))
        err("Argument df is not a data frame")
    if (!is.list(keepList))
        err("Argument keepList is not a list")
    keepAND = rep(TRUE, nrow(df))
    idxs = c()
    if (length(keepList) > 0)
        idxs = 1:length(keepList)
    for (iAND in idxs)
        {
        ANDlist = keepList[[iAND]]
        if (!is.list(ANDlist))
            err("keepList element is not a list")
        keepOR = rep(FALSE, nrow(df))
        for (ORlist in ANDlist)
            {
            if (!is.list(ORlist))
                err("keepList sub-list contains an element that is not a list")
            if (length(ORlist) < 2)
                err("Length of keepList sub-sublist is less than 2")
            col = ORlist[[1]]
            if (!col %in% colnames(df))
                err("keepList refers to column '", col, "' but there is no such column")
            colVals = df[,col]
            ops = c("NA", "=", "!=", ">", ">=", "<", "<=", "in", "not_in")
            op = ORlist[[2]]
            if (is.na(op))
                op = "NA"
            if (!is.character(op))
                err("keepList operator for column '", col, "' is not a character string, it is type ", class(op))
            if (!op %in% ops)
                err("operator for column '", col, "' was not one of: ", paste(ops, collapse=","))
            if (op == "NA")
                keepRows = is.na(colVals)
            else if (op %in% c("in", "not_in"))
                {
                if (length(ORlist) != 3)
                    err("Length of sublist for column '", col, "' was not 3")
                keepRows = (colVals %in% ORlist[[3]])
                if (op == "not_in")
                    keepRows = !keepRows
                }
            else
                {
                if (length(ORlist) != 3)
                    err("Length of sublist for column '", col, "' was not 3")
                val = ORlist[[3]]
                if (op == "=" || op == "!=")
                    keepRows = (colVals == val)
                else if (op == ">=" || op == "<")
                    keepRows = (colVals >= val)
                else # (op == "<=" || op == ">")
                    keepRows = (colVals <= val)
                if (op %in% c("!=", "<", ">"))
                    keepRows = !keepRows
                }
            keepOR = keepOR | keepRows
            }

        if (!allowEmpty && !any(keepOR))
            err("no data retained by keepList sublist #", iAND)
        keepAND = keepAND & keepOR
        if (!allowEmpty && !any(keepAND))
            err("no data retained following AND-ing of keepList sublist #", iAND)
        }
    df = df[keepAND,]
    return(df)
    }

########################################
# If possible, shorten a vector S of strings so that none is longer than N characters,
# by removing terminal string characters until either all strings are N or fewer
# characters or until removal of a character would make two strings identical.
# Shortened names have * placed at their end, implying that at least two characters
# were removed.
########################################
shortenStrings = function(S, N)
    {
    if (length(S) == 1)
        return(S)
    origLens = nchar(S)
    origNmax = max(origLens)
    # See how short we can make the longest string and still have all strings be
    # unique.  However, no need to go shorter than Nmax-1.  We need to go to that
    # rather than just to Nmax, because all shortened strings will have "*" added
    # to the end.
    S2 = S
    Nmax = origNmax
    while (!any(duplicated(S2)) && Nmax > N-2)
        {
        Nmax = Nmax - 1
        S2 = substr(S2, 1, Nmax)
        }
    # Nmax is equal to the length at which duplicated strings appear.  That means
    # means that there were no duplicated strings at Nmax+1 (unless there were
    # some in the original list).  Truncate at Nmax+1 and add * to truncated
    # strings IF Nmax+2 is < origNmax.  The truncated strings will have length
    # Nmax+2.  To ensure that we try to get this to be <= N, we make the above
    # loop continue (if possible) until Nmax == N-2.
    if (Nmax+2 < origNmax)
        {
        S = substr(S, 1, Nmax+1)
        shortened = (nchar(S) < origLens)
        S[shortened] = paste0(S[shortened], "*")
        }
    return(S)
    }

################################################################################
# Find permutation order of objects to sort them in increasing order.  This function is
# like the function "order", and calls it with the ... arguments, returning its value.
# This function differs from order() in that it does special sorting on digits, the
# motivation being to sort a list of strings such that e.g. "chr10" sorts AFTER "chr9".
#
# Arguments:
#   ...: one or more vectors, all of same length, either character or convertible to
#       character, defining the desired sorting order.  Sorting occurs on the first
#       argument, with ties broken by the second argument, 2nd-level ties by third,
#       etc.  These arguments may be named, and must be named if the "lead0" argument
#       is used (argument names, not names of elements of the vectors).
#   lead0: vector of names of one or more of the ... arguments, which are to be
#       analyzed for strings of digits that are converted to longer strings by
#       adding leading 0's, so that all digit strings in that argument are the same
#       length.  If NULL, use first ... argument (use empty vector for none).
#   first: a single vector or list of vectors, each vector giving the values within
#       the ... argument vectors that are to appear FIRST in sorted order.  If a
#       vector is specified for "first", its elements apply to the first ... argument,
#       while if a list is specified, each of its vector elements must have a name
#       that matches the name of the ... argument to which the vector is to be applied.
#       The order of values in a vector determine their sorting order.
#   last: like "first", but this determines values in ... vectors that are to appear
#       LAST in order.
# Returns: The permutation order, the same as order() returns.
#
# This function adds leading zeroes to each string of 1 or more digits surrounded
# by non-digits so that all digit strings are the same length (the length of the longest
# digit string in any of the arguments), and sorting occurs on the modified values.
# Thus, this can be used to sort many types of data, not just a list of ILs.
# E.g. to sort the IL-rows of a data frame df by "IL" (with leading zeroes added), then
# columns "chr" then "start":
#   ord = order.special(rownames(df), df$chr, df$start)
#   df = df[ord,]
# As with order(), there can be more than one argument.  By default, only the first
# argument is modified to add leading zeroes to number strings.  The argument "lead0"
# can be specified to give the names of ... arguments to be modified with leading
# zeroes.
# E.g. to sort the rows of a data frame df by columns "trait" then "IL" (with leading
# zeroes added) then "pos":
#   ord = order.special(df$trait, ILs=df$IL, df$pos, lead0="ILs")
#   df = df[ord,]
# Use the "first" and "last" arguments to list particular values which should sort to
# the start or end.  These arguments each are either a list or vector.  A vector is
# applied to the first ... argument and gives the values which are to be first or last
# in the sorted order.  A list value for "first" or "last" has as its elements vectors
# whose names are ... argument names naming the arguments to which the vectors apply,
# and the vectors contain the values within those arguments to be first or last in
# sorted order.
# E.g. to sort the rows of a data frame df by IL (with leading zeroes added for sorting
# purposes and with "M82" first and "PENN" last) and then by chr then start:
#   ord = order.special(rownames(df), df$chr, df$start, first="M82", last="PENN")
#   df = df[ord,]
# or to sort by columns "trait" then "IL" (with leading zeroes added and both M82 and
# PENN appearing first) then "pos":
#   ord = order.special(df$trait, ILs=df$IL, df$pos, lead0="ILs", first=list(ILs=c("M82", "PENN")))
#   df = df[ord,]
################################################################################
order.special = function(..., lead0=NULL, first=NULL, last=NULL)
    {
    args = list(...)
    if (length(args) == 0) stop("order.special error: must give at least one ... arg")
    for (arg in args[-1])
    if (length(arg) != length(args[[1]])) stop("order.special error: all ... args must be same length")
    if (length(args[[1]]) == 0)
        return(integer(0))

    # Provide default for lead0.
    if (is.null(lead0))
        lead0 = 1
    # Make first and last be either NULL or lists.
    if (!is.null(first) && !is.list(first))
        {
        first = list(first)
        names(first) = names(args)[1]
        if (is.null(names(first)))
            names(first) = 1
        }
    if (!is.null(last) && !is.list(last))
        {
        last = list(last)
        names(last) = names(args)[1]
        if (is.null(names(last)))
            names(last) = 1
        }
    # Make sure first and last lists have names.
    if (is.list(first) && is.null(names(first))) stop("order.special error: expected 'first' arg to have names")
    if (is.list(last) && is.null(names(last))) stop("order.special error: expected 'last' arg to have names")

    # To sort first or last, we will modify any vector requiring such sorting so
    # that its elements start with either "A", "B", or "C" depending on whether
    # they are to sort first (A), middle (B), or last (C).  Furthermore, while
    # middle-sorting elements consist of "C" followed by the element value,
    # elements sorting first or last consist of "A" or "B" followed by a 9-digit
    # number that is the index of the element value in the "first" or "last"
    # vector, filled with leading 0's.  This ensures that these elements will
    # sort in the same order as they occur in "first" or "last".
    isModified = rep(FALSE, length(args)) # Track which args vectors are modified, for use when doing "last".
    names(isModified) = names(args)
    for (argName in names(first))
        {
        if (grepl("^[0-9]+$", argName))
            idx = as.integer(argName)
        else
            idx = which(argName == names(args))
        if (length(idx) != 1) stop("order.special error: expected 'first' arg list element name to match an argument name")
        V = as.character(args[[idx]])
        matches = match(V, first[[argName]])
        V[!is.na(matches)] = sprintf("A%09d", matches[!is.na(matches)])
        V[is.na(matches)] = paste0("B", V[is.na(matches)])
        args[[idx]] = V
        isModified[idx] = TRUE
        }
    # Now do "last".
    for (argName in names(last))
        {
        idx = which(argName == names(args))
        if (length(idx) != 1) stop("order.special error: expected 'last' arg list element name to match an argument name")
        V = as.character(args[[idx]])
        # If we already modified this vector when doing "first" above, then we
        # won't find the "last" elements, but rather, those with "B" prepended.
        # (If "A" is prepended, the value appears in both "first" and "last"
        # vectors, let the "first" vector have precedence.)
        V.last = last[[argName]]
        if (isModified[idx])
            V.last = paste0("B", V.last)
        matches = match(V, V.last)
        V[!is.na(matches)] = sprintf("C%09d", matches[!is.na(matches)])
        # If this args vector was already modified, we don't need to prepend "B".
        if (!isModified[idx])
            V[is.na(matches)] = paste0("B", V[is.na(matches)])
        args[[idx]] = V
        }

    # For each argument name in lead0 (or index 1 if lead0 wasn't specified), add
    # leading zeroes to number strings in the argument.
    for (idx in lead0)
        {
        if (grepl("^[0-9]+$", idx))
            idx = as.integer(idx)
        V = args[[idx]]
        # Find length of longest digit string so we know the number of digits including
        # leading 0's that each digit substring will be set to.  Construct a regular expression and
        # its replacement, for adding leading zeroes.
        digitStrs = strsplit(as.character(args[[1]]), "[^0-9]+")
        NdigitsMax = max(sapply(digitStrs, function(V) max(c(0,nchar(V)))))
        if (NdigitsMax > 1)
            {
            RE = paste0("(^|[^0-9])([0-9]{1,", NdigitsMax-1, "})([^0-9]|$)")
            repRE = "\\10\\2\\3"
            # Keep applying the regular expression until no further changes occur.
            while (TRUE)
                {
                Vnew = gsub(RE, repRE, V)
                if (all(Vnew == V, na.rm=TRUE))
                    break
                V = Vnew
                }
            # Replace the argument by the modified strings with leading zeroes.
            args[[idx]] = V
            }
        }
    # Now call order with the arguments, and return its return value.
    return(do.call(order, args))
    }

################################################################################
# Convert a list of vectors, such as returned by strsplit(), into a data frame
# where each row is one element of the list, and each column is one element of
# the subvectors.
#
# Arguments:
#   L: List of vectors.
#   colNames: vector of column names for columns of returned data frame.
#   minSublistLen: minimum number of elements in each list vector.
#   maxSubvecLen: maximum number of elements in each list vector, 0 for no limit.
#
# Returns: data frame with columns as given by colNames, of length length(L).
#
# Note: if any list vector has fewer than minSubvecLen or more than maxSubvecLen
# elements, an error occurs.  If a list vector has more than length(colNames)
# elements, those beyond length(colNames) are ignored.  If a list vector has
# fewer than length(colNames) elements, the remaining values are set to NA in
# the returned data frame.
################################################################################
dfFromListList = function(L, colNames, minSubvecLen=length(colNames), maxSubvecLen=length(colNames))
    {
    if (is.null(L))
        return(NULL)
    if (!is.list(L) || !is.vector(L[[1]]))
        stop("dfFromListList only works with NULL or list of vectors arguments")

    counts = sapply(L, length)
    N.counts = length(counts)
    R = range(counts)
    if (R[1] < minSubvecLen)
        stop("Minimum L list vector length is ", R[1], ", less than minSubvecLen=", minSubvecLen)
    if (maxSubvecLen > 0 && R[2] > maxSubvecLen)
        stop("Maximum L list vector length is ", R[2], ", more than maxSubvecLen=", maxSubvecLen)

    # The trick to speeding this up is to work out the row and column indexes
    # in a matrix into which to store each unlisted element.
    V = unlist(L, use.names=FALSE)
    N.V = length(V)
    cum.counts = cumsum(counts)
    row.idx = rep(0, N.V)
    row.idx[c(1, 1+cum.counts[-N.counts])] = 1
    row.idx = cumsum(row.idx)
    col.idx = rep(1, N.V+N.counts-1)
    col.idx[(1:(N.counts-1)+cum.counts[-N.counts])] = -counts[-N.counts]
    col.idx = cumsum(col.idx)
    col.idx = col.idx[col.idx != 0]

    # Create the matrix, store the data, then convert to data frame.
    mtx = matrix(NA, nrow=N.counts, ncol=R[2])
    mtx[matrix(c(row.idx, col.idx), ncol=2)] = V
    mtx = mtx[, 1:length(colNames)]
    colnames(mtx) = colNames
    return(as.data.frame(mtx, stringsAsFactors=FALSE))
    }

################################################################################
# Suppose you have a vector "sa" of strings, each of which is 0 or more substrings
# separated by sep1, and each of those substrings is N sub-substrings separated by
# sep2, where Ns > 1.  You wish to split first by sep1, then by sep2, and obtain a
# data frame with columns "idx", "A1", "A2", ... "AN" containing the fully-split data,
# with the columns "A1" ... containing the individual sub-substrings, and column "idx"
# For example, suppose sa is:
#   sa
#   -----
#   A=HELLO,B=10,D=TRUE
#   B=9.8,C=John,D=F
#   A=BYE,C=Dan
#
# And you wish to generate this data frame:
#
#   idx   Var   Val
#   ---   ---   ---
#   1       A   "HELLO"
#   1       B   "10"
#   1       D   "TRUE"
#   2       B   "9.8"
#   2       C   "John"
#   2       D   "F"
#   3       A   "BYE"
#   3       C   "Dan"
#
# This can be done with the following expression, MUCH FASTER than doing a
# strsplit() followed by an sapply(..strsplit) followed by data frame manipulation:
#   sa = c("A=HELLO,B=10,D=TRUE", "B=9.8,C=John,D=F", "A=BYE,C=Dan")
#   df = strsplitsplit(sa, ",", "=", c("Var", "Val"))
#
# If you then wanted a vector whose names are from column "Var" and whose values
# are from column "Val":
#   V = makeNamedVector(df$Var, df$Val)
#
# Arguments:
#   sa: vector of strings containing substrings separated by sep1.
#   sep1: the regular expression or string that is to separate the substrings.
#   sep2: the regular expression or string that separates each substring into sub-substrings.
#   colNames: vector of column names for columns after column 1 of the returned
#       data frame.
#   sep1Fixed: TRUE if sep1 is fixed, FALSE if it is a regular expression.
#   sep2Fixed: TRUE if sep2 is fixed, FALSE if it is a regular expression.
#   minSubsubstrings: minimum number of sub-substrings that each substring separates into.
#   maxSubsubstrings: maximum number of sub-substrings that each substring separates into.
#
# Returns: data frame with columns "idx" and colNames.
#
# Note: if any substring has fewer than minSubsubstrings or more than maxSubsubstrings
# sub-substrings, an error occurs.  If a substring has more than length(colNames)
# sub-substrings, those beyond length(colNames) are ignored.  If a substring has fewer
# than length(colNames) sub-substrings, the remaining values are set to NA in the
# returned data frame.
################################################################################
strsplitsplit = function(sa, sep1, sep2, colNames, sep1Fixed=TRUE, sep2Fixed=TRUE,
    minSubsubstrings=length(colNames), maxSubsubstrings=length(colNames))
    {
    L = strsplit(sa, sep1, fixed=sep1Fixed)
    counts = sapply(L, length)
    V = unlist(L, use.names=FALSE)
    idx = rep(0, length(V))
    idx[c(1, 1+cumsum(counts)[-length(counts)])] = 1
    idx = cumsum(idx)
    L.V = strsplit(V, sep2, fixed=sep2Fixed)
    df = dfFromListList(L.V, colNames, minSubsubstrings, maxSubsubstrings)
    if (length(idx) != nrow(df))
        stop("strsplitsplit: unexpected mismatch")
    df = cbind(idx, df)
    return(df)
    }

################################################################################
# Suppose you have a vector "sa" of strings, and a separate vector "fa" of the same
# length is a factor that gives the category of each string in sa.  You wish to
# generate a new vector of the same length as the NUMBER OF UNIQUE CATEGORIES (number
# of levels of fa), with each element of the vector being a string of the pasted
# strings in sa within that category, separated by a comma.  For example, suppose fa
# and sa are:
#   sa      fa
#   -----   ------
#   Jane    Female
#   Sally   Female
#   Pam     Female
#   Sue     Female
#   Tom     Male
#   John    Male
#   Mike    Male
#
# And you wish to generate this vector v:
#
#   names   vector v
#   ------  -------------------------------
#   Female  "Jane,Sally,Pam,Sue"
#   Male    "Tom,John,Mike"
#
# This can be done with the following expression:
# sa = c("Jane","Sally","Pam","Sue","Tom","John","Mike")
# fa = c("Female","Female","Female","Female","Male","Male","Male")
# v = tapply(sa, fa, function(S) paste(S, collapse=","))
#
# This function does EXACTLY THE SAME THING.  However, it does it in a way that is
# MUCH FASTER than the above if the number of levels of fa is quite large.
#
# Arguments:
#   fa: vector of strings that categorize each element of sa.
#   sa: vector of strings to be pasted together, same length as fa.
#   sep: the string that is to separate the pasted-together strings.
#   uniqueSep: a unique string not appearing in sa that can be temporarily used to
#       separate concatenated sa elements for later splitting apart.
#   sorted: TRUE if fa (and sa) is sorted so all identical members are adjacent,
#       FALSE if not (this function will sort them).
#   fai: either the vector return by "match(unique(fa), fa)" or NULL.
#   ret.fai: TRUE if fai member is to be returned, see below.
# Returns: list with these members:
#   v: array of same length as nlevels(factor(fa)) containing pasted-together strings
#       of sa found within that level of fa, separated by the specified sep string.
#   fai: NA if ret.fai is FALSE, else number vector of same length as v, containing
#       the vector returned by "match(unique(fa), fa)".
################################################################################
tapply_paste = function(fa, sa, sep=",", uniqueSep="*", sorted=TRUE, fai=NULL, ret.fai=FALSE)
    {
    if (!sorted)
        {
        ord = order(fa)
        fa = fa[ord]
        sa = sa[ord]
        }
    if (is.null(fai))
        fai = match(unique(fa), fa)
    sa[fai] = paste0(uniqueSep, sa[fai])
    sa = paste0(sa, collapse=sep)
    sa = unlist(strsplit(sa, uniqueSep, fixed=TRUE))
    sa = sa[-1]
    names(sa) = fa[fai]
    L = list(v=sa, fai=NA)
    if (ret.fai)
        L$fai = fai
    return(L)
    }

################################################################################
# Suppose you have a vector "sa" of strings, and each string consists of one or more
# words separated by commas.  A separate vector "fa" of the same length is a factor
# that gives the category of each string in sa.  You wish to generate a new vector
# of the same length as the NUMBER OF UNIQUE CATEGORIES (number of levels of fa),
# with each element of the vector being a string of the unique words found in sa within
# that category, separated by commas.  For example, suppose fa and sa are:
#   name    fa      sa
#   -----   ------  ---------------------
#   Jane    Female  "cat,dog"
#   Sally   Female  "cat,mouse,dog"
#   Pam     Female  "dog"
#   Sue     Female  "cat,fish"
#   Tom     Male    "cat,dog,bird,snake"
#   John    Male    "dog,rat"
#   Mike    Male    "cat,monkey"
#
# And you wish to generate this vector v:
#
#   names   vector v
#   ------  -------------------------------
#   Female  "cat,dog,mouse,fish"
#   Male    "cat,dog,bird,snake,rat,monkey"
#
# This can be done with the following expression:
# sa = c("cat,dog","cat,mouse,dog","dog","cat,fish","cat,dog,bird,snake","dog,rat","cat,monkey")
# fa = c("Female","Female","Female","Female","Male","Male","Male")
# v = as.vector(tapply(sa, fa, function(S) paste(unique(unlist(strsplit(S,","))), collapse=",")))
#
# This function does EXACTLY THE SAME THING.  However, it does it in a way that is
# MUCH FASTER than the above if the number of unique words in the entire sa array is
# small compared to the number of levels of fa.  This function has a loop that loops
# for the number of unique words in sa; the "tapply()" method basically loops for each
# factor level.
#
# Arguments:
#   fa: vector of strings that categorize each element of sa.
#   sa: vector of strings that are splittable on some substring, same length as fa.
#   split: the substring that can split each string of sa into separate substrings.
#   sep: the string that is to separate each word in the result.
#   uniqueSep: a unique string not appearing in sa that can be temporarily used to
#       separate concatenated sa elements for later splitting apart.
#   sorted: TRUE if fa (and sa) is sorted so all identical members are adjacent,
#       FALSE if not (this function will sort them).
#   fai: either the vector return by "match(unique(fa), fa)" or NULL.
#   ret.fai: TRUE if fai member is to be returned, see below.
# Returns: list with these members:
#   v: array of same length as nlevels(factor(fa)) containing unique substrings of
#       sa found within that level of fa, separated by the specified split string.
#   fai: NA if ret.fai is FALSE, else number vector of same length as v, containing
#       the vector returned by "match(unique(fa), fa)".
################################################################################
tapply_unique_strsplit = function(fa, sa, split=",", sep=split, uniqueSep="*",
    sorted=TRUE, fai=NULL, ret.fai=FALSE)
    {
    if (!sorted)
        {
        ord = order(fa)
        fa = fa[ord]
        sa = sa[ord]
        }
    uniqueStrings = unique(unlist(strsplit(sa, split, fixed=TRUE)))
    if (is.null(fai))
        fai = match(unique(fa), fa)
    sa[fai] = paste0(uniqueSep, split, sa[fai])
    sa = paste0(sa, collapse=split)
    sa = paste0(sa, split)
    sa = unlist(strsplit(sa, uniqueSep, fixed=TRUE))
    sa = sa[-1]
    v = character(length(sa))
    for (s in uniqueStrings)
        {
        s.bounded = paste0(split, s, split)
        has.s = grepl(s.bounded, sa, fixed=TRUE)
        v[has.s] = paste(v[has.s], s, sep=sep)
        }
    v = substring(v, 1+nchar(sep))
    names(v) = fa[fai]
    L = list(v=v, fai=NA)
    if (ret.fai)
        L$fai = fai
    return(L)
    }

################################################################################
# Perform Wilcoxon single-sample signed-rank tests on values of subsets of a
# data frame column, to create a p-value for each subset, testing for the mean
# of the values being greater, less, or not significantly different from a
# specified value.  The p-values are adjusted for multiple hypothesis testing
# using the fdr method (Benjamini and Hochberg).
#
# Arguments:
#   dfTest: data frame of values to be tested and their subset ID.  Must include
#       columns specified by "IDcol", "Vcol", and "meanCols" arguments.
#   IDcol: name of dfTest column containing a value used to split dfTest into
#       subsets of values.
#   Vcol: name of dfTest column containing the values to be tested.
#   meanCols: names of zero or more dfTest columns whose mean value is to be
#       computed for each subset of values, with result column name being this
#       name with ".mean" appended.  This might be the same as 'Vcol'.
#   compareTo: value to which to compare the Vcol values in the Wilcoxon test.
#   signifDigits: number of significant digits in returned p.value, q.value, and
#       *.mean columns.
#
# Returns: data frame with these columns:
#   <IDcol>: column name given by IDcol argument, column contains all the unique
#       values in that column of dfTest.  Number of returned rows is the number
#       of unique values.
#   NM: number of values in the subset.
#   p.less: p-value resulting from testing the Vcol values to see if their mean
#       is < "compareTo" value.
#   p.greater: p-value resulting from testing the Vcol values to see if their
#       mean is > "compareTo" value.
#   p.wilcox: the smaller of p.less and p.greater.
#   p.value: p.wilcox modified to contain only signifDigits significant digits.
#   p.type: "GREATER" if p.greater < p.less, indicating mean Vcol > compareTo.
#            "LESS" if p.less < p.greater, indicating mean Vcol < compareTo.
#   <meanCols>.mean: for each value in argument meanCols, the mean of that
#       column of dfTest is computed for each subset and placed in this column
#       of the returned data frame, ROUNDED to signifDigits digits.
#   q.fdr: p.wilcox adjusted for multiple hypothesis testing (number of unique
#       subsets is the number of tests done) using the FDR method.  This is
#       modified to contain only signifDigits significant digits.
#   phred: phred-scaled value of q.fdr.
#
# Note: Each subset of values is tested twice, each test being a single-tailed
# Wilcoxon single-sample signed rank test, once to test for Vcol < compareTo,
# once to test for Vcol > compareTo.
#
# Note: if any subset has fewer than 2 values, the returned data frame contains
# NA in all columns except <IDcol> and NM.  (The meanCols columns are NA only if
# there are 0 values).
################################################################################
WilcoxonTest = function(dfTest, IDcol, Vcol, meanCols=c(), compareTo=1.0, signifDigits=2)
    {
    if (!IDcol %in% colnames(dfTest))
        stop("dfTest does not contain ID column ", IDcol)
    if (!Vcol %in% colnames(dfTest))
        stop("dfTest does not contain value column ", Vcol)
    if (!all(meanCols %in% colnames(dfTest)))
        stop("dfTest does not contain all 'mean' columns ", paste(meanCols, collapse=","))
    if (length(meanCols) > 0)
        meanCols.mean = paste0(meanCols, ".mean")

    # Apply the test to each subset, each of which returns a 1-row data frame
    # with columns NM, meanVals, p.less, and p.greater.
    A.Wilcox = tapply(1:nrow(dfTest), dfTest[[IDcol]], function(ii)
        {
        # Get values and their number.
        V = dfTest[[Vcol]][ii]
        NM = length(V)

        # Make return data frame.
        df = data.frame(NM=NM, p.less=NA, p.greater=NA, stringsAsFactors=FALSE)
        # If a subset has at least 2 values, perform the tests.
        if (NM >= 2)
            {
            df$p.less = wilcox.test(V-compareTo, alternative="less", exact=FALSE)$p.value
            df$p.greater = wilcox.test(V-compareTo, alternative="greater", exact=FALSE)$p.value
            }

        # Compute the means.
        if (length(meanCols) > 0)
            {
            meanVals = rep(NA, length(meanCols))
            if (NM > 0)
                meanVals = sapply(meanCols, function(meanCol) round(mean(dfTest[[meanCol]][ii]), signifDigits))
            df[, meanCols.mean] = meanVals
            }
        return(df)
        }, simplify=FALSE)

    # Combine results into a single data frame.
    dfWilcox = do.call(rbind, A.Wilcox)

    # Add the IDcol column.
    dfWilcox[[IDcol]] = names(A.Wilcox)

    # Choose which p-value to return in p.value.
    dfWilcox$p.wilcox = dfWilcox$p.greater
    ind = (!is.na(dfWilcox$p.less) & dfWilcox$p.less < dfWilcox$p.greater)
    dfWilcox$p.wilcox[ind] = dfWilcox$p.less[ind]
    dfWilcox$p.value = signif(dfWilcox$p.wilcox, signifDigits)
    dfWilcox$p.type = myIfElse(ind, "LESS", "GREATER")

    # If we have any non-NA p-values, do multiple testing correction on them and
    # compute phred-scaled q.fdr.
    dfWilcox$q.fdr = NA
    dfWilcox$phred = NA
    ind = !is.na(dfWilcox$p.wilcox)
    if (any(ind))
        {
        dfWilcox$q.fdr[ind] = signif(p.adjust(dfWilcox$p.wilcox[ind], method="fdr"), signifDigits)
        dfWilcox$phred[ind] = round(-10*log10(dfWilcox$q.fdr[ind]))
        ind = (ind & dfWilcox$phred == Inf)
        if (any(ind))
            dfWilcox$phred[ind] = round(-10*log10(.Machine$double.xmin))
        }
    return(dfWilcox)
    }

################################################################################
# Log-likelihood tests of independence & goodness of fit
# Does Williams' and Yates' correction.
# Does Monte Carlo simulation of p-values, via gtestsim.c.
#
# G & q calculation from Sokal & Rohlf (1995) Biometry 3rd ed.
# TOI Yates' correction taken from Mike Camann's 2x2 G-test fn.
# GOF Yates' correction as described in Zar (2000)
# More stuff taken from ctest's chisq.test()
#
# V3.3 Pete Hurd Sept 29 2001. phurd@ualberta.ca
################################################################################
g.test = function(x, y=NULL, correct=c("williams", "yates", "none"),
    p=rep(1/length(x), length(x)), simulate.p.value=FALSE, B=2000)
    {
    DNAME = deparse(substitute(x))
    if (is.data.frame(x)) x = as.matrix(x)
    if (is.matrix(x))
        {
        if (min(dim(x)) == 1)
            x = as.vector(x)
        }
    if (!is.matrix(x) && !is.null(y))
        {
        if (length(x) != length(y))
            stop("x and y must have the same length")
        DNAME = paste(DNAME, "and", deparse(substitute(y)))
        OK = complete.cases(x, y)
        x = as.factor(x[OK])
        y = as.factor(y[OK])
        if ((nlevels(x) < 2) || (nlevels(y) < 2))
            stop("x and y must have at least 2 levels")
        x = table(x, y)
        }
    if (any(x < 0) || any(is.na(x)))
        stop("all entries of x must be nonnegative and finite")
    if ((n = sum(x)) == 0)
        stop("at least one entry of x must be positive")
    # If x is matrix, do test of independence
    if (is.matrix(x))
        {
        # Test of Independence
        nrows = nrow(x)
        ncols = ncol(x)
        if (correct[1]=="yates")
            { # Do Yates' correction?
            if(dim(x)[1]!=2 || dim(x)[2]!=2) # check for 2x2 matrix
                stop("Yates' correction requires a 2 x 2 matrix")
            if((x[1,1]*x[2,2])-(x[1,2]*x[2,1]) > 0)
                {
                x[1,1] = x[1,1] - 0.5
                x[2,2] = x[2,2] - 0.5
                x[1,2] = x[1,2] + 0.5
                x[2,1] = x[2,1] + 0.5
                }
            else
                {
                x[1,1] = x[1,1] + 0.5
                x[2,2] = x[2,2] + 0.5
                x[1,2] = x[1,2] - 0.5
                x[2,1] = x[2,1] - 0.5
                }
            }

        sr = apply(x, 1, sum)
        sc = apply(x, 2, sum)
        E = outer(sr, sc, "*")/n
        # are we doing a monte-carlo?
        # no monte carlo GOF?
        if (simulate.p.value)
            {
            METHOD = paste("Log likelihood ratio (G-test) test of independence\n\t with simulated p-value based on", B, "replicates")
            tmp = .C("gtestsim", as.integer(nrows), as.integer(ncols),
                                as.integer(sr), as.integer(sc), as.integer(n), as.integer(B),
                                as.double(E), integer(nrows * ncols), double(n+1),
                                integer(ncols), results=double(B), PACKAGE= "ctest")
            g = 0
            for (i in 1:nrows)
                {
                for (j in 1:ncols)
                    {
                    if (x[i,j] != 0) g = g + x[i,j] * log(x[i,j]/E[i,j])
                    }
                }
            STATISTIC = G = 2 * g
            PARAMETER = NA
            PVAL = sum(tmp$results >= STATISTIC)/B
            }
        else
            {
            # no monte-carlo
            # calculate G
            g = 0
            for (i in 1:nrows)
                {
                for (j in 1:ncols)
                    {
                    if (x[i,j] != 0) g = g + x[i,j] * log(x[i,j]/E[i,j])
                    }
                }
            q = 1
            if (correct[1]=="williams")
                { # Do Williams' correction
                row.tot = col.tot = 0
                for (i in 1:nrows)
                    { row.tot = row.tot + 1/(sum(x[i,]))     }
                for (j in 1:ncols)
                    { col.tot = col.tot + 1/(sum(x[,j]))     }
                q = 1+ ((n*row.tot-1)*(n*col.tot-1))/(6*n*(ncols-1)*(nrows-1))
                }
            STATISTIC = G = 2 * g / q
            PARAMETER = (nrow(x)-1)*(ncol(x)-1)
            PVAL = 1-pchisq(STATISTIC, df=PARAMETER)
            if(correct[1]=="none")
                METHOD = "Log likelihood ratio (G-test) test of independence without correction"
            if(correct[1]=="williams")
                METHOD = "Log likelihood ratio (G-test) test of independence with Williams' correction"
            if(correct[1]=="yates")
                METHOD = "Log likelihood ratio (G-test) test of independence with Yates' correction"
            }
        }
    else
        {
        # x is not a matrix, so we do Goodness of Fit
        METHOD = "Log likelihood ratio (G-test) goodness of fit test"
        if (length(x) == 1)
            stop("x must at least have 2 elements")
        if (length(x) != length(p))
            stop("x and p must have the same number of elements")
        E = n * p

        if (correct[1]=="yates")
            { # Do Yates' correction
            if(length(x)!=2)
                stop("Yates' correction requires 2 data values")
            if ( (x[1]-E[1]) > 0.25)
                {
                x[1] = x[1]-0.5
                x[2] = x[2]+0.5
                }
            else if ( (E[1]-x[1]) > 0.25)
                {
                x[1] = x[1]+0.5
                x[2] = x[2]-0.5
                }
            }
        names(E) = names(x)
        g = 0
        for (i in 1:length(x))
            {
            if (x[i] != 0) g = g + x[i] * log(x[i]/E[i])
            }
        q = 1
        if (correct[1]=="williams")
            { # Do Williams' correction
            q = 1+(length(x)+1)/(6*n)
            }
        STATISTIC = G = 2*g/q
        PARAMETER = length(x) - 1
        PVAL = pchisq(STATISTIC, PARAMETER, lower = FALSE)
        }
    names(STATISTIC) = "Log likelihood ratio statistic (G)"
    names(PARAMETER) = "X-squared df"
    names(PVAL) = "p.value"
    structure(list(statistic=STATISTIC, parameter=PARAMETER, p.value=PVAL,
                        method=METHOD, data.name=DNAME, observed=x, expected=E),
                        class="htest")
    }

################################################################################
# Suppress specific messages (regular or warning or error) coming from a
# function call.  (Normally you would not ignore an error message, but just in
# case the issue comes up and ignoring it will produce correct results, this
# allows error messages to be ignored too.)
#
# Arguments:
#   expr: an R expression to evaluate.
#   ...: one or more regular expressions to be applied to any message generated as a
#       result of evaluating "expr".  If any expression matches the message, it is
#       suppressed, else it is printed.  Note that messages sometimes end in "\n" so
#       make sure that is matched if the regular expression ends with $.  Also note
#       that multiple regular expressions can be specified as either separate arguments
#       or as single arguments that are vectors of regular expressions.
#   warningsToErrors: if TRUE, warnings not matched by the regular expressions are
#       turned into errors.
#
# Returns: whatever is returned by evaluation of the expression.
#
# Notes: look at implementation of function message() and read the R help on the
# functions used in it.  Then search on web, e.g.
# http://adv-r.had.co.nz/beyond-exception-handling.html
#
# Example:
#     t.cor = muffleMessages(
#            {
#            cor.test(gene1.log2Counts, gene2.log2Counts, alternative="two.sided", method=corMethod)
#            }, "Cannot compute exact p-value with ties", warningsToErrors=TRUE)
################################################################################
muffleMessages = function(expr, ..., warningsToErrors=FALSE)
    {
    REs = list(...)

    # Search for a regular expression matching msg and return TRUE iff found.
    anyMatch = function(msg, s)
        {
        cat0("anyMatch: ", s, "  :", msg, "\n")
        for (REvec in REs)
            for (RE in REvec)
                if (grepl(RE, msg))
                    return(TRUE)
        return(FALSE)
        }

    # Search for a restart and invoke it if found.
    doRestart = function(restart)
        {
        r = findRestart(restart)
        if (is.null(r))
            return()
        invokeRestart(r)
        }

    # Establish simpleMessage and simpleWarning handlers, then evaluate the expression.
    withCallingHandlers(
        simpleMessage=function(m) { if (anyMatch(conditionMessage(m), "simpleMessage")) doRestart("muffleMessage") },
        simpleWarning=function(w)
            {
            if (anyMatch(conditionMessage(w), "simpleWarning"))
                doRestart("muffleWarning")
            if (warningsToErrors)
                stop(paste("  (Warning in ", Reduce(paste, deparse(w$call)), ")   : ", w$message, sep=""), call.=FALSE)
            },
        simpleError=function(e) { if (anyMatch(conditionMessage(e), "simpleError")) doRestart("muffleWarning") },
        expr)
    }

################################################################################
# Use this to measure how long it takes R to do something, in seconds, see example below.
#
# Get the current proc.time() and subtract a previous proc.time() from it, saving both
# the current and delta CPU time (sum of user and system time) in a list.  Accumulate
# delta time in a specified time slot.  Optionally convert the cumulative values in the
# delta time slots to units of minutes.
#
# Arguments:
#   L: A list to which elements are added if not present.  The list is returned, and
#       must be specified as the L argument in the next call to this function.  On the
#       first call this argument may be left off to default to an empty list.
#   i: Index (or name) of a time slot into which to add the delta CPU time for this call.
#       Each call to this function can specify a different index, see example below.
#       Use NULL to not update any cumulative time slot.
#   cvt: If TRUE, the return list contains an updated cumDeltaCPUdifftime member.
#
# Returns: list with these members:
#       last: the proc.time() value found this call to the function.
#       delta: the difference in total CPU time (user+system) between the current
#           time and the previous time this function was called with the same list.
#           When this function is called with an empty list as in the default case
#           normally used on the first call, delta will be 0.
#       cum: a vector of cumulative delta times, indexed by index values provided by
#           argument i.
#       cvt: cum converted to a difftime object, if cvt is not FALSE.
#
# Example:
# L = getDeltaCpuTime()
# for (k in bigVector)
#   {
#   doSomething()
#   L = getDeltaCpuTime(L, "doSomething")
#   doSomethingElse()
#   L = getDeltaCpuTime(L, "doSomethingElse")
#   }
# L = getDeltaCpuTime(L, cvt=TRUE)
# for (n in names(L$cvt))
#   cat("Time for", n, ":", L$cvt[n], "secs\n")
################################################################################
getDeltaCpuTime = function(L=list(), i=NULL, cvt=FALSE)
    {
    cur = proc.time()
    if (!is.list(L))
        L = list()
    if (is.null(L$last) || any(is.na(L$last)))
        L$last = cur
    if (is.null(L$cum) || any(is.na(L$cum)))
        L$cum = numeric()
    t = cur - L$last
    L$last = cur
    L$delta = as.numeric(t[1]) + as.numeric(t[2]) # User + system CPU time
    if (!is.null(i))
        {
        if (is.null(L$cum[i]) || any(is.na(L$cum[i])))
            L$cum[i] = L$delta
        else
            L$cum[i] = L$cum[i] + L$delta
        }
    if (!cvt)
        {
        L$cvt = c()
        for (idx in 1:length(L$cum))
            L$cvt[idx] = as.difftime(L$cum[idx], units="secs")
        names(L$cvt) = names(L$cum)
        }
    return(L)
    }

################################################################################
# Get the current proc.time() and subtract a previous proc.time() from it.  Convert
# the result to a CPU processor time as a difftime in units of minutes and return it.
# Use this to measure how long it takes R to do something, like this:
#  prevTime = proc.time()
#  (now do some time-consuming stuff)
#  minutes = getDiffCpuTime(prevTime)
#  cat("It took", minutes, "minutes to do it.\n")
################################################################################
getDiffCpuTime = function(prevTime)
    {
    curTime = proc.time()
    t = curTime - prevTime
    cpu = as.numeric(t[1]) + as.numeric(t[2]) # User + system CPU time, don't use elapsed time!
    t = as.difftime(cpu, units="secs")
    units(t) = "mins"
    return(t)
    }

################################################################################
# A, B, and C are three non-colinear 2D points.  Return the point D on line AB
# such that CD is perpendicular to AB.  A, B, and C are either vectors of length
# 2 or they are lists of such vectors.  If lists, a list of vectors of points D
# is returned, else a vector of length 2 is returned for D.
#
# The point is given by:
#   D = A + AC * (AB . AC) / |AC|^2
# where A = line from origin to A, AB . AC is dot product of those two vectors,
# and |AC| is length of vector AC.
#
#   A = c(10, 5)
#   B = c(3, 8)
#   C = c(14, 9)
#   getPtOnLinePerpToP(A, B, C)  # (11.9, 4.2) # Good.
#   getPtOnLinePerpToP(list(A, B, A), list(B, A, B), list(C, C, C))  # Good.
################################################################################
getPtOnLinePerpToP = function(A, B, C)
    {
    if (is.list(A))
        {
        if (!is.list(B) || !is.list(C)) stop("Expected B and C to also be lists")
        if (length(B) != length(A) || length(C) != length(A)) stop("Expected A, B and C to be same length")
        D = list()
        for (i in 1:length(A))
            D = c(D, list(getPtOnLinePerpToP(A[[i]], B[[i]], C[[i]])))
        return(D)
        }
    AB = B - A
    AC = C - A
    dp = sum(AB*AC)
    lensqr = sum(AB*AB)
    D = A + AB*dp/lensqr
    return(D)
    }

################################################################################
# The 2D points A and B define line segment AB and C and D define line segment
# CD.  Return the point E on line CD such that AB and AE are perpendicular, or
# if AB and CD are perpendicular, there is no such point so return (NA, NA).
# A, B, C, and D are either vectors of length 2 or they are lists of such
# vectors.  If lists, a list of vectors of points E is returned, else a vector
# of length 2 is returned for E.
#
# I'm not sure if there is a concise way to represent the solution.  However,
# it can be represented using a series of steps:
#   a. Translate A to the origin by subtracting A from all points (P->P')
#   b. Rotate points about origin until B' lies on the positive X axis (P'->P")
#   c. E" is then easily found as E" = (0, (C" x D") / (Dx" - Cx")
#   d. Rotate points so B" returns to the original B' position (P"->P')
#   e. Translate origin to original A position by adding A to all points (P'->P)
#
# The x- and y-components of a point P are designated Px and Py, and P = (Px, Py)
# The 2D vector dot-product of vectors A and B is designated A . B, and
#   A . B = (Ax*Bx + Ay*By)
# The 2D vector cross-product of vectors A and B is designated A x B, and
#   A x B = (Ax*By - Ay*Bx)
# The length of a vector P is designated ||P||, and ||P|| = sqrt(Px*Px+Py*Py)
# The squared length of vector P is designated |P|, and |P| = Px*Px+Py*Py
# The perpendicular to a point P, of the same length and at a 90º CCW rotation,
#   is designated P⌞, and P⌞ = (-Py, Px)
# A rotation of a point P' that maps point B' to a position on the positive
#   x-axis and is designated by P", is given by P" = (B . P, B x P) / ||B'||
# The inverse (same angle but CW instead of CCW rotation) rotation of P" back
#   to P' is P' = (B*c(1,-1) . P, B*c(1,-1) x P) / ||B'||
#
# These can then be assembled into the final solution:
#   a. A' = (0, 0), B' = B - A, C' = C - A, D' = D - A
#   b. ||B'|| = sqrt(Bx'*Bx'+By'*By')
#   c. C" = (B' . C', B' x C') / ||B'||, D" = (B' . D', B' x D') / ||B'||
#   d. C" x D" = Cx"*Dy" - Cy"*Dx"
#   e. E" = (0, (C" x D") / (Cx" - Dx")
#   f. Bb' = B' * (1,-1)
#   g. E' = (Bb' . E, Bb' x E) / ||B'||
#   h. E = A + E'
#
# It would be nice if it were possible to factor out the ||B'|| in such a way
# that we did not have to take any square roots, which slow things down.  If we
# designate ||P|| squared as |P| = Px*Px+Py*Py, then we note that in step d,
# C" x D" has |B'| in the denominator from step c.  In steps e and f the terms
# include a factor of ||B'|| / |B'| = 1/||B'||, and in step g that factor times
# ||B'|| in the denominator gives |B'| in the denominator.  Using those
# factorizations and re-using the variable names for different, scaled values
# gives us:
#   a. B' = B - A, C' = C - A, D' = D - A
#   b. C" = (B' . C', B' x C'), D" = (B' . D', B' x D')
#   c. E" = (0, (Cx"*Dy" - Cy"*Dx") / (Cx" - CD")
#   d. Bb' = B' * (1,-1)
#   e. E = A + (Bb' . E, Bb' x E) / |B'|
#
# We can also simplify since Ex" = 0:
#   c. Ey" = (Cx"*Dy" - Cy"*Dx") / (Cx" - Dx")
#   d. Bb' = B' * (1,-1)
#   e. E = A + (Bb'y*Ey", Bb'x*Ey") / |B'|
#
# And, steps d and e can be simplified:
#   d. B⌞' = (-By', Bx')
#   e. E = A + Ey"*B⌞' / |B'|
#
# or even more simply, leave out step d:
#   d. E = A + Ey"*(-By', Bx') / |B'|
#
# For notation, instead of P' we use PA since P' = P-A.  Instead of P⌞ we use
# Pp (p for perpendicular).  Instead of P" we use Pr (r for rotated; Actually
# PAp, PAr).
#
# getPtOnLine1PerpToLine2(c(0,0), c(1,0), c(-2,2), c(2,6))  # (0,4) good
# getPtOnLine1PerpToLine2(c(0,0), c(1,0), c(-2,2), c(-3,1))  # (0,4) good
# getPtOnLine1PerpToLine2(c(0,0), c(-50,0), c(100,104), c(101,105))  # (0,4) good
# getPtOnLine1PerpToLine2(c(0,0), c(1,0), c(2,6), c(-2,2))  # (0,4) good
# getPtOnLine1PerpToLine2(c(10,10), c(11,10), c(8,12), c(12,16))  # (10,14) good
# getPtOnLine1PerpToLine2(c(0,0), c(5,0), c(-2,2), c(2,6))  # (0,4) good
# getPtOnLine1PerpToLine2(c(0,0), c(-5,0), c(-2,2), c(2,6))  # (0,4) good
# getPtOnLine1PerpToLine2(c(0,0), c(1,0), c(-2,-2), c(2,-6))  # (0,-4) good
# getPtOnLine1PerpToLine2(c(0,0), c(0,1), c(-2,-2), c(-6,2))  # (-4,0) good
# getPtOnLine1PerpToLine2(c(0,0), c(0,1), c(2,-2), c(6,2))  # (4,0) good
# getPtOnLine1PerpToLine2(c(0,0), c(1,1), c(-6,1), c(-2,6))  # (-3.7,3.7) good
# getPtOnLine1PerpToLine2(c(10,100), c(11,101), c(4,101), c(8,106))  # (6.2,103.7) good
# getPtOnLine1PerpToLine2(c(15,26), c(7.5,13), c(25,-72), c(25,26))  # (25,20) good
#
## Useful testing functions.
##dot = function(A, B) A[1]*B[1]+A[2]*B[2]
##cross = function(A, B) A[1]*B[2]-A[2]*B[1]
##len = function(P) sqrt(sum(P*P))
##len_sqrd = function(P) sum(P*P)
##perp = function(P) c(-P[2], P[1])
##rot = function(B, P) c(dot(B, P), cross(B, P))/len(B)
##invrot = function(B, P) rot(c(B[1], -B[2]), P)
##pp = function(P, col="black", pch=20) points(P[1], P[2], col=col, pch=pch)
##ll = function(P1, P2, col="black") segments(P1[1], P1[2], P2[1], P2[2], col=col)
##plot(NA, type="n", xlim=c(-10,10), ylim=c(-10,10))
##ll(c(-10, 0), c(10,0))
##ll(c(0, -10), c(0, 10))
##O = c(0,0)
##P = c(2,3)
##pp(P)
##ll(O,P)
##cat(len(P), "\n")
##cat(len_sqrd(P), "\n")
##P2 = perp(P)
##pp(P2)
##ll(O,P2)
##P3 = c(4,8)
##pp(P3, "blue")
##ll(O, P3, "blue")
##Pr = rot(P, P)
##pp(Pr, "darkgrey")
##P3r = rot(P, P3)
##pp(P3r, "blue")
##ll(O, P3r, "blue")
##Pro = invrot(P, Pr)
##pp(Pro, "darkgrey", pch=4)
##P3ro = invrot(P, P3r)
##pp(P3ro, "blue", pch=4)
################################################################################
getPtOnLine1PerpToLine2 = function(A, B, C, D)
    {
    if (is.list(A))
        {
        if (!is.list(B) || !is.list(C) || !is.list(D)) stop("Expected B, C, and D to also be lists")
        if (length(B) != length(A) || length(C) != length(A) || length(D) != length(A))
            stop("Expected A, B, C, and D to be same length")
        E = list()
        for (i in 1:length(A))
            E = c(E, list(getPtOnLine1PerpToLine2(A[[i]], B[[i]], C[[i]], D[[i]])))
        return(E)
        }
    #   a. B' = B - A, C' = C - A, D' = D - A
    BA = B - A
    CA = C - A
    DA = D - A
    #   b. C" = (B' . C', B' x C'), D" = (B' . D', B' x D')
    CAr = c(BA[1]*CA[1]+BA[2]*CA[2], BA[1]*CA[2]-BA[2]*CA[1])
    DAr = c(BA[1]*DA[1]+BA[2]*DA[2], BA[1]*DA[2]-BA[2]*DA[1])
    if (CAr[1] == DAr[1]) # AB and CD are perpendicular?
        return(c(NA, NA))
    #   c. Ey" = (Cx"*Dy" - Cy"*Dx") / (Cx" - Dx")
    EAry = (CAr[1]*DAr[2] - CAr[2]*DAr[1]) / (CAr[1] - DAr[1])
    #   d. E = A + Ey"*(-By', Bx') / |B'|
    E = A + EAry*c(-BA[2], BA[1]) / sum(BA^2)
    if (any(is.na(E) | is.nan(E))) stop("getPtOnLine1PerpToLine2 E=", E[1], ",", E[2],
        " A=", A[1], ",", A[2],
        " B=", B[1], ",", B[2],
        " C=", C[1], ",", C[2],
        " D=", D[1], ",", D[2])
    return(E)
    }

################################################################################
# Given colinear 2D points A, B, or C, return 0 if C lies between A and B, else
# return 1 if C is on or closer to A, and 2 if it is on or closer to B.  If A,
# B, and C are lists, they must be the same size, and each list element must be
# a 2D point (vector of length 2), and the return value is a vector of the same
# length as the lists, containing 0, 1, or 2 for each of the points A, B, and C
# in the lists.  If either coordinate of C is NA or NaN, return 3.
################################################################################
checkPtBetweenAB = function(A, B, C)
    {
    if (is.list(A))
        {
        if (!is.list(B) || !is.list(C)) stop("Expected B and C to also be lists")
        if (length(B) != length(A) || length(C) != length(A)) stop("Expected A, B and C to be same length")
        x = c()
        for (i in 1:length(A))
            x = c(x, checkPtBetweenAB(A[[i]], B[[i]], C[[i]]))
        return(x)
        }
    dABsqr = sum((B-A)^2)
    dACsqr = sum((C-A)^2)
    dBCsqr = sum((C-B)^2)
    if (is.na(dACsqr) || is.nan(dACsqr))
        return(3)
    if (dACsqr < dABsqr)
        {
        if (dBCsqr < dABsqr)
            return(0)
        return(1)
        }
    if (dACsqr < dBCsqr)
        return(1)
    return(2)
    }

################################################################################
# End of file.
################################################################################
Sourced.Include_UtilityFunctions = TRUE
cat("  Include_UtilityFunctions.R included\n")
